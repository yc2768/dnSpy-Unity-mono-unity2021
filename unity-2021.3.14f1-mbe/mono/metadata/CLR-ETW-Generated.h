//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once

//*****************************************************************************
//
// Notes on the ETW event code generated by MC:
//
// - Structures and arrays of structures are treated as an opaque binary blob.
//   The caller is responsible for packing the data for the structure into a
//   single region of memory, with no padding between values. The macro will
//   have an extra parameter for the length of the blob.
// - Arrays of nul-terminated strings must be packed by the caller into a
//   single binary blob containing the correct number of strings, with a nul
//   after each string. The size of the blob is specified in characters, and
//   includes the final nul.
// - Arrays of SID are treated as a single binary blob. The caller is
//   responsible for packing the SID values into a single region of memory with
//   no padding.
// - The length attribute on the data element in the manifest is significant
//   for values with intype win:UnicodeString, win:AnsiString, or win:Binary.
//   The length attribute must be specified for win:Binary, and is optional for
//   win:UnicodeString and win:AnsiString (if no length is given, the strings
//   are assumed to be nul-terminated). For win:UnicodeString, the length is
//   measured in characters, not bytes.
// - For an array of win:UnicodeString, win:AnsiString, or win:Binary, the
//   length attribute applies to every value in the array, so every value in
//   the array must have the same length. The values in the array are provided
//   to the macro via a single pointer -- the caller is responsible for packing
//   all of the values into a single region of memory with no padding between
//   values.
// - Values of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary can be generated and collected on Vista or later.
//   However, they may not decode properly without the Windows 10 2018 Fall
//   Update.
// - Arrays of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary must be packed by the caller into a single region of
//   memory. The format for each item is a UINT16 byte-count followed by that
//   many bytes of data. When providing the array to the generated macro, you
//   must provide the total size of the packed array data, including the UINT16
//   sizes for each item. In the case of win:CountedUnicodeString, the data
//   size is specified in WCHAR (16-bit) units. In the case of
//   win:CountedAnsiString and win:CountedBinary, the data size is specified in
//   bytes.
//
//*****************************************************************************

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>

#ifndef ETW_INLINE
  #ifdef _ETW_KM_
    // In kernel mode, save stack space by never inlining templates.
    #define ETW_INLINE DECLSPEC_NOINLINE __inline
  #else
    // In user mode, save code size by inlining templates as appropriate.
    #define ETW_INLINE __inline
  #endif
#endif // ETW_INLINE

#if defined(__cplusplus)
extern "C" {
#endif

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_USE_KERNEL_MODE_APIS macro:
// Controls whether the generated code uses kernel-mode or user-mode APIs.
// - Set to 0 to use Windows user-mode APIs such as EventRegister.
// - Set to 1 to use Windows kernel-mode APIs such as EtwRegister.
// Default is based on whether the _ETW_KM_ macro is defined (i.e. by wdm.h).
// Note that the APIs can also be overridden directly, e.g. by setting the
// MCGEN_EVENTWRITETRANSFER or MCGEN_EVENTREGISTER macros.
//
#ifndef MCGEN_USE_KERNEL_MODE_APIS
  #ifdef _ETW_KM_
    #define MCGEN_USE_KERNEL_MODE_APIS 1
  #else
    #define MCGEN_USE_KERNEL_MODE_APIS 0
  #endif
#endif // MCGEN_USE_KERNEL_MODE_APIS

//
// MCGEN_HAVE_EVENTSETINFORMATION macro:
// Controls how McGenEventSetInformation uses the EventSetInformation API.
// - Set to 0 to disable the use of EventSetInformation
//   (McGenEventSetInformation will always return an error).
// - Set to 1 to directly invoke MCGEN_EVENTSETINFORMATION.
// - Set to 2 to to locate EventSetInformation at runtime via GetProcAddress
//   (user-mode) or MmGetSystemRoutineAddress (kernel-mode).
// Default is determined as follows:
// - If MCGEN_EVENTSETINFORMATION has been customized, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else if the target OS version has EventSetInformation, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else set to 2 (i.e. try to dynamically locate EventSetInformation).
// Note that an McGenEventSetInformation function will only be generated if one
// or more provider in a manifest has provider traits.
//
#ifndef MCGEN_HAVE_EVENTSETINFORMATION
  #ifdef MCGEN_EVENTSETINFORMATION             // if MCGEN_EVENTSETINFORMATION has been customized,
    #define MCGEN_HAVE_EVENTSETINFORMATION   1 //   directly invoke MCGEN_EVENTSETINFORMATION(...).
  #elif MCGEN_USE_KERNEL_MODE_APIS             // else if using kernel-mode APIs,
    #if NTDDI_VERSION >= 0x06040000            //   if target OS is Windows 10 or later,
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EtwSetInformation" via MmGetSystemRoutineAddress.
    #endif                                     // else (using user-mode APIs)
  #else                                        //   if target OS and SDK is Windows 8 or later,
    #if WINVER >= 0x0602 && defined(EVENT_FILTER_TYPE_SCHEMATIZED)
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EventSetInformation" via GetModuleHandleExW/GetProcAddress.
    #endif
  #endif
#endif // MCGEN_HAVE_EVENTSETINFORMATION

//
// MCGEN Override Macros
//
// The following override macros may be defined before including this header
// to control the APIs used by this header:
//
// - MCGEN_EVENTREGISTER
// - MCGEN_EVENTUNREGISTER
// - MCGEN_EVENTSETINFORMATION
// - MCGEN_EVENTWRITETRANSFER
//
// If the the macro is undefined, the MC implementation will default to the
// corresponding ETW APIs. For example, if the MCGEN_EVENTREGISTER macro is
// undefined, the EventRegister[MyProviderName] macro will use EventRegister
// in user mode and will use EtwRegister in kernel mode.
//
// To prevent issues from conflicting definitions of these macros, the value
// of the override macro will be used as a suffix in certain internal function
// names. Because of this, the override macros must follow certain rules:
//
// - The macro must be defined before any MC-generated header is included and
//   must not be undefined or redefined after any MC-generated header is
//   included. Different translation units (i.e. different .c or .cpp files)
//   may set the macros to different values, but within a translation unit
//   (within a single .c or .cpp file), the macro must be set once and not
//   changed.
// - The override must be an object-like macro, not a function-like macro
//   (i.e. the override macro must not have a parameter list).
// - The override macro's value must be a simple identifier, i.e. must be
//   something that starts with a letter or '_' and contains only letters,
//   numbers, and '_' characters.
// - If the override macro's value is the name of a second object-like macro,
//   the second object-like macro must follow the same rules. (The override
//   macro's value can also be the name of a function-like macro, in which
//   case the function-like macro does not need to follow the same rules.)
//
// For example, the following will cause compile errors:
//
//   #define MCGEN_EVENTWRITETRANSFER MyNamespace::MyClass::MyFunction // Value has non-identifier characters (colon).
//   #define MCGEN_EVENTWRITETRANSFER GetEventWriteFunctionPointer(7)  // Value has non-identifier characters (parentheses).
//   #define MCGEN_EVENTWRITETRANSFER(h,e,a,r,c,d) EventWrite(h,e,c,d) // Override is defined as a function-like macro.
//   #define MY_OBJECT_LIKE_MACRO     MyNamespace::MyClass::MyEventWriteFunction
//   #define MCGEN_EVENTWRITETRANSFER MY_OBJECT_LIKE_MACRO // Evaluates to something with non-identifier characters (colon).
//
// The following would be ok:
//
//   #define MCGEN_EVENTWRITETRANSFER  MyEventWriteFunction1  // OK, suffix will be "MyEventWriteFunction1".
//   #define MY_OBJECT_LIKE_MACRO      MyEventWriteFunction2
//   #define MCGEN_EVENTWRITETRANSFER  MY_OBJECT_LIKE_MACRO   // OK, suffix will be "MyEventWriteFunction2".
//   #define MY_FUNCTION_LIKE_MACRO(h,e,a,r,c,d) MyNamespace::MyClass::MyEventWriteFunction3(h,e,c,d)
//   #define MCGEN_EVENTWRITETRANSFER  MY_FUNCTION_LIKE_MACRO // OK, suffix will be "MY_FUNCTION_LIKE_MACRO".
//
#ifndef MCGEN_EVENTREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTREGISTER        EtwRegister
  #else
    #define MCGEN_EVENTREGISTER        EventRegister
  #endif
#endif // MCGEN_EVENTREGISTER
#ifndef MCGEN_EVENTUNREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTUNREGISTER      EtwUnregister
  #else
    #define MCGEN_EVENTUNREGISTER      EventUnregister
  #endif
#endif // MCGEN_EVENTUNREGISTER
#ifndef MCGEN_EVENTSETINFORMATION
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTSETINFORMATION  EtwSetInformation
  #else
    #define MCGEN_EVENTSETINFORMATION  EventSetInformation
  #endif
#endif // MCGEN_EVENTSETINFORMATION
#ifndef MCGEN_EVENTWRITETRANSFER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTWRITETRANSFER   EtwWriteTransfer
  #else
    #define MCGEN_EVENTWRITETRANSFER   EventWriteTransfer
  #endif
#endif // MCGEN_EVENTWRITETRANSFER

//
// MCGEN_EVENT_ENABLED macro:
// Override to control how the EventWrite[EventName] macros determine whether
// an event is enabled. The default behavior is for EventWrite[EventName] to
// use the EventEnabled[EventName] macros.
//
#ifndef MCGEN_EVENT_ENABLED
#define MCGEN_EVENT_ENABLED(EventName) EventEnabled##EventName()
#endif

//
// MCGEN_EVENT_ENABLED_FORCONTEXT macro:
// Override to control how the EventWrite[EventName]_ForContext macros
// determine whether an event is enabled. The default behavior is for
// EventWrite[EventName]_ForContext to use the
// EventEnabled[EventName]_ForContext macros.
//
#ifndef MCGEN_EVENT_ENABLED_FORCONTEXT
#define MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EventName) EventEnabled##EventName##_ForContext(pContext)
#endif

//
// MCGEN_ENABLE_CHECK macro:
// Determines whether the specified event would be considered as enabled
// based on the state of the specified context. Slightly faster than calling
// McGenEventEnabled directly.
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled && McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
// This structure is for use by MC-generated code and should not be used directly.
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE            RegistrationHandle;
    TRACEHANDLE            Logger;      // Used as pointer to provider traits.
    ULONGLONG              MatchAnyKeyword;
    ULONGLONG              MatchAllKeyword;
    ULONG                  Flags;
    ULONG                  IsEnabled;
    UCHAR                  Level;
    UCHAR                  Reserve;
    USHORT                 EnableBitsCount;
    PULONG                 EnableBitMask;
    const ULONGLONG*       EnableKeyWords;
    const UCHAR*           EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif // MCGEN_TRACE_CONTEXT_DEF

#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
//
// Determines whether an event with a given Level and Keyword would be
// considered as enabled based on the state of the specified context.
// Note that you may want to use MCGEN_ENABLE_CHECK instead of calling this
// function directly.
//
FORCEINLINE
BOOLEAN
McGenLevelKeywordEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((Keyword == (ULONGLONG)0) ||
            ((Keyword & EnableInfo->MatchAnyKeyword) &&
             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // MCGEN_LEVEL_KEYWORD_ENABLED_DEF

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
//
// Determines whether the specified event would be considered as enabled based
// on the state of the specified context. Note that you may want to use
// MCGEN_ENABLE_CHECK instead of calling this function directly.
//
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
}
#endif // MCGEN_EVENT_ENABLED_DEF

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Windows Vista and later.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider.

    ControlCode - The parameter indicates whether the provider
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category
                      of events that the provider writes.

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
    ULONG Ix;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;

            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
                } else {
                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
                }
            }
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            if (Ctx->EnableBitsCount > 0) {
#pragma warning(suppress: 26451) // Arithmetic overflow cannot occur, no matter the value of EnableBitCount
                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
            }
            break;

        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif // MCGEN_PRIVATE_ENABLE_CALLBACK_V2

    return;
}

#endif // MCGEN_CONTROL_CALLBACK

#ifndef _mcgen_PENABLECALLBACK
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define _mcgen_PENABLECALLBACK      PETWENABLECALLBACK
  #else
    #define _mcgen_PENABLECALLBACK      PENABLECALLBACK
  #endif
#endif // _mcgen_PENABLECALLBACK

#if !defined(_mcgen_PASTE2)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE2(a, b) _mcgen_PASTE2_imp(a, b)
#define _mcgen_PASTE2_imp(a, b) a##b
#endif // _mcgen_PASTE2

#if !defined(_mcgen_PASTE3)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE3(a, b, c) _mcgen_PASTE3_imp(a, b, c)
#define _mcgen_PASTE3_imp(a, b, c) a##b##_##c
#endif // _mcgen_PASTE3

//
// Macro validation
//

// Validate MCGEN_EVENTREGISTER:

// Trigger an error if MCGEN_EVENTREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER);

// Trigger an error if MCGEN_EVENTREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER)
    MCGEN_EVENTREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTREGISTER);

// Validate MCGEN_EVENTUNREGISTER:

// Trigger an error if MCGEN_EVENTUNREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER);

// Trigger an error if MCGEN_EVENTUNREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER)
    MCGEN_EVENTUNREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTUNREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTUNREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTUNREGISTER);

// Validate MCGEN_EVENTSETINFORMATION:

// Trigger an error if MCGEN_EVENTSETINFORMATION is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION);

// Trigger an error if MCGEN_EVENTSETINFORMATION is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION)
    MCGEN_EVENTSETINFORMATION_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTSETINFORMATION is defined as a function-like macro:
typedef void MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_MCGEN_EVENTSETINFORMATION;
typedef int _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_, MCGEN_EVENTSETINFORMATION);

// Validate MCGEN_EVENTWRITETRANSFER:

// Trigger an error if MCGEN_EVENTWRITETRANSFER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER);

// Trigger an error if MCGEN_EVENTWRITETRANSFER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER)
    MCGEN_EVENTWRITETRANSFER_must_not_be_redefined_between_headers;;

// Trigger an error if MCGEN_EVENTWRITETRANSFER is defined as a function-like macro:
typedef void MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_MCGEN_EVENTWRITETRANSFER;
typedef int _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_, MCGEN_EVENTWRITETRANSFER);

#ifndef McGenEventWrite_def
#define McGenEventWrite_def

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventWrite _mcgen_PASTE2(McGenEventWrite_, MCGEN_EVENTWRITETRANSFER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventWrite(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_range_(1, 128) ULONG EventDataCount,
    _Pre_cap_(EventDataCount) EVENT_DATA_DESCRIPTOR* EventData
    )
{
    const USHORT UNALIGNED* Traits;

    // Some customized MCGEN_EVENTWRITETRANSFER macros might ignore ActivityId.
    UNREFERENCED_PARAMETER(ActivityId);

    Traits = (const USHORT UNALIGNED*)(UINT_PTR)Context->Logger;

    if (Traits == NULL) {
        EventData[0].Ptr = 0;
        EventData[0].Size = 0;
        EventData[0].Reserved = 0;
    } else {
        EventData[0].Ptr = (ULONG_PTR)Traits;
        EventData[0].Size = *Traits;
        EventData[0].Reserved = 2; // EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA
    }

    return MCGEN_EVENTWRITETRANSFER(
        Context->RegistrationHandle,
        Descriptor,
        ActivityId,
        NULL,
        EventDataCount,
        EventData);
}
#endif // McGenEventWrite_def

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventRegister _mcgen_PASTE2(McGenEventRegister_, MCGEN_EVENTREGISTER)

#pragma warning(push)
#pragma warning(disable:6103)
// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ _mcgen_PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Inout_ PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function registers the provider with ETW.

Arguments:

    ProviderId - Provider ID to register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for the callback.

    RegHandle - Pointer to registration handle.

Remarks:

    Should not be called if the provider is already registered (i.e. should not
    be called if *RegHandle != 0). Repeatedly registering a provider is a bug
    and may indicate a race condition. However, for compatibility with previous
    behavior, this function will return SUCCESS in this case.

--*/
{
    ULONG Error;

    if (*RegHandle != 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTREGISTER(ProviderId, EnableCallback, CallbackContext, RegHandle);
    }

    return Error;
}
#pragma warning(pop)

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventUnregister _mcgen_PASTE2(McGenEventUnregister_, MCGEN_EVENTUNREGISTER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW and set *RegHandle = 0.

Arguments:

    RegHandle - the pointer to the provider registration handle

Remarks:

    If provider has not been registered (i.e. if *RegHandle == 0),
    return SUCCESS. It is safe to call McGenEventUnregister even if the
    call to McGenEventRegister returned an error.

--*/
{
    ULONG Error;

    if(*RegHandle == 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTUNREGISTER(*RegHandle);
        *RegHandle = (REGHANDLE)0;
    }

    return Error;
}

#endif // McGenEventRegisterUnregister

#ifndef _mcgen_EVENT_BIT_SET
  #if defined(_M_IX86) || defined(_M_X64)
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((((const unsigned char*)EnableBits)[BitPosition >> 3] & (1u << (BitPosition & 7))) != 0)
  #else // CPU type
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((EnableBits[BitPosition >> 5] & (1u << (BitPosition & 31))) != 0)
  #endif // CPU type
#endif // _mcgen_EVENT_BIT_SET

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntime" event count 168
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = e13c0d23-ccbc-4e12-931b-d9cc2eee27e4
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER = {0xe13c0d23, 0xccbc, 0x4e12, {0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits

//
// Opcodes
//
#define CLR_GC_RESTARTEEEND_OPCODE 0x84
#define CLR_GC_HEAPSTATS_OPCODE 0x85
#define CLR_GC_CREATESEGMENT_OPCODE 0x86
#define CLR_GC_FREESEGMENT_OPCODE 0x87
#define CLR_GC_RESTARTEEBEING_OPCODE 0x88
#define CLR_GC_SUSPENDEEND_OPCODE 0x89
#define CLR_GC_SUSPENDEEBEGIN_OPCODE 0xa
#define CLR_GC_ALLOCATIONTICK_OPCODE 0xb
#define CLR_GC_CREATECONCURRENTTHREAD_OPCODE 0xc
#define CLR_GC_TERMINATECONCURRENTTHREAD_OPCODE 0xd
#define CLR_GC_FINALIZERSEND_OPCODE 0xf
#define CLR_GC_FINALIZERSBEGIN_OPCODE 0x13
#define CLR_GC_BULKROOTEDGE_OPCODE 0x14
#define CLR_GC_BULKROOTCONDITIONALWEAKTABLEELEMENTEDGE_OPCODE 0x15
#define CLR_GC_BULKNODE_OPCODE 0x16
#define CLR_GC_BULKEDGE_OPCODE 0x17
#define CLR_GC_OBJECTALLOCATION_OPCODE 0x18
#define CLR_GC_BULKSURVIVINGOBJECTRANGES_OPCODE 0x19
#define CLR_GC_BULKMOVEDOBJECTRANGES_OPCODE 0x1a
#define CLR_GC_GENERATIONRANGE_OPCODE 0x1b
#define CLR_GC_MARKSTACKROOTS_OPCODE 0x1c
#define CLR_GC_MARKFINALIZEQUEUEROOTS_OPCODE 0x1d
#define CLR_GC_MARKHANDLES_OPCODE 0x1e
#define CLR_GC_MARKCARDS_OPCODE 0x1f
#define CLR_GC_FINALIZEOBJECT_OPCODE 0x20
#define CLR_GC_SETGCHANDLE_OPCODE 0x21
#define CLR_GC_DESTROYGCHANDLE_OPCODE 0x22
#define CLR_GC_TRIGGERED_OPCODE 0x23
#define CLR_GC_PINGCOBJECT_OPCODE 0x24
#define CLR_GC_BULKROOTCCW_OPCODE 0x26
#define CLR_GC_BULKRCW_OPCODE 0x27
#define CLR_GC_BULKROOTSTATICVAR_OPCODE 0x28
#define CLR_GC_DYNAMICEVENT_OPCODE 0x29
#define CLR_GC_INCREASEMEMORYPRESSURE_OPCODE 0xc8
#define CLR_GC_DECREASEMEMORYPRESSURE_OPCODE 0xc9
#define CLR_GC_MARK_OPCODE 0xca
#define CLR_GC_JOIN_OPCODE 0xcb
#define CLR_GC_GCPERHEAPHISTORY_OPCODE 0xcc
#define CLR_GC_GCGLOBALHEAPHISTORY_OPCODE 0xcd
#define CLR_GC_GCLOADED_OPCODE 0xce
#define CLR_METHOD_DCSTARTCOMPLETE_OPCODE 0xe
#define CLR_METHOD_DCENDCOMPLETE_OPCODE 0xf
#define CLR_METHOD_METHODLOAD_OPCODE 0x21
#define CLR_METHOD_METHODUNLOAD_OPCODE 0x22
#define CLR_METHOD_METHODDCSTART_OPCODE 0x23
#define CLR_METHOD_METHODDCEND_OPCODE 0x24
#define CLR_METHOD_METHODLOADVERBOSE_OPCODE 0x25
#define CLR_METHOD_METHODUNLOADVERBOSE_OPCODE 0x26
#define CLR_METHOD_METHODDCSTARTVERBOSE_OPCODE 0x27
#define CLR_METHOD_METHODDCENDVERBOSE_OPCODE 0x28
#define CLR_METHOD_METHODJITTINGSTARTED_OPCODE 0x2a
#define CLR_JITINLININGSUCCEEDED_OPCODE 0x53
#define CLR_JITINLININGFAILED_OPCODE 0x54
#define CLR_JITTAILCALLSUCCEEDED_OPCODE 0x55
#define CLR_JITTAILCALLFAILED_OPCODE 0x56
#define CLR_METHODILTONATIVEMAP_OPCODE 0x57
#define CLR_DOMAINMODULELOAD_OPCODE 0x2d
#define CLR_MODULELOAD_OPCODE 0x21
#define CLR_MODULEUNLOAD_OPCODE 0x22
#define CLR_MODULEDCSTART_OPCODE 0x23
#define CLR_MODULEDCEND_OPCODE 0x24
#define CLR_ASSEMBLYLOAD_OPCODE 0x25
#define CLR_ASSEMBLYUNLOAD_OPCODE 0x26
#define CLR_APPDOMAINLOAD_OPCODE 0x29
#define CLR_APPDOMAINUNLOAD_OPCODE 0x2a
#define CLR_STACK_STACKWALK_OPCODE 0x52
#define CLR_APPDOMAINRESOURCEMANAGEMENT_APPDOMAINMEMALLOCATED_OPCODE 0x30
#define CLR_APPDOMAINRESOURCEMANAGEMENT_APPDOMAINMEMSURVIVED_OPCODE 0x31
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADCREATED_OPCODE 0x32
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADTERMINATED_OPCODE 0x33
#define CLR_APPDOMAINRESOURCEMANAGEMENT_THREADDOMAINENTER_OPCODE 0x34
#define CLR_ILSTUB_ILSTUBGENERATED_OPCODE 0x58
#define CLR_ILSTUB_ILSTUBCACHEHIT_OPCODE 0x59
#define CLR_WAIT_OPCODE 0x5a
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_SAMPLE_OPCODE 0x64
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_ADJUSTMENT_OPCODE 0x65
#define CLR_THREADPOOL_WORKERTHREADADJUSTMENT_STATS_OPCODE 0x66
#define CLR_PERFTRACK_MODULERANGELOAD_OPCODE 0xa
#define CLR_BULKTYPE_OPCODE 0xa
#define CLR_ENQUEUE_OPCODE 0xb
#define CLR_DEQUEUE_OPCODE 0xc
#define CLR_IOENQUEUE_OPCODE 0xd
#define CLR_IODEQUEUE_OPCODE 0xe
#define CLR_IOPACK_OPCODE 0xf
#define CLR_THREAD_CREATING_OPCODE 0xb
#define CLR_THREAD_RUNNING_OPCODE 0xc

//
// Tasks
//
#define CLR_GC_TASK 0x1
EXTERN_C __declspec(selectany) const GUID GarbageCollectionId = {0x044973cd, 0x251f, 0x4dff, {0xa3, 0xe9, 0x9d, 0x63, 0x07, 0x28, 0x6b, 0x05}};
#define CLR_WORKERTHREADCREATE_TASK 0x2
EXTERN_C __declspec(selectany) const GUID WorkerThreadCreationId = {0xcfc4ba53, 0xfb42, 0x4757, {0x8b, 0x70, 0x5f, 0x5d, 0x51, 0xfe, 0xe2, 0xf4}};
#define CLR_IOTHREADCREATE_TASK 0x3
EXTERN_C __declspec(selectany) const GUID IOThreadCreationId = {0xc71408de, 0x42cc, 0x4f81, {0x9c, 0x93, 0xb8, 0x91, 0x2a, 0xbf, 0x2a, 0x0f}};
#define CLR_WORKERTHREADRETIRE_TASK 0x4
EXTERN_C __declspec(selectany) const GUID WorkerThreadRetirementId = {0xefdf1eac, 0x1d5d, 0x4e84, {0x89, 0x3a, 0x19, 0xb8, 0x0f, 0x69, 0x21, 0x76}};
#define CLR_IOTHREADRETIRE_TASK 0x5
EXTERN_C __declspec(selectany) const GUID IOThreadRetirementId = {0x840c8456, 0x6457, 0x4eb7, {0x9c, 0xd0, 0xd2, 0x8f, 0x01, 0xc6, 0x4f, 0x5e}};
#define CLR_THREADPOOLSUSPEND_TASK 0x6
EXTERN_C __declspec(selectany) const GUID ThreadpoolSuspensionId = {0xc424b3e3, 0x2ae0, 0x416e, {0xa0, 0x39, 0x41, 0x0c, 0x5d, 0x8e, 0x5f, 0x14}};
#define CLR_EXCEPTION_TASK 0x7
EXTERN_C __declspec(selectany) const GUID ExceptionId = {0x300ce105, 0x86d1, 0x41f8, {0xb9, 0xd2, 0x83, 0xfc, 0xbf, 0xf3, 0x2d, 0x99}};
#define CLR_EXCEPTION_CATCH_TASK 0x1b
EXTERN_C __declspec(selectany) const GUID ExceptionCatchId = {0x5bbf9499, 0x1715, 0x4658, {0x88, 0xdc, 0xaf, 0xd7, 0x69, 0x0a, 0x87, 0x11}};
#define CLR_EXCEPTION_FINALLY_TASK 0x1c
EXTERN_C __declspec(selectany) const GUID ExceptionFinallyId = {0x9565bc31, 0x300f, 0x4ea2, {0xa5, 0x32, 0x30, 0xbc, 0xe9, 0xa1, 0x41, 0x99}};
#define CLR_EXCEPTION_FILTER_TASK 0x1d
EXTERN_C __declspec(selectany) const GUID ExceptionFilterId = {0x72e72606, 0xbb71, 0x4290, {0xa2, 0x42, 0xd5, 0xf3, 0x6c, 0xe5, 0x31, 0x2e}};
#define CLR_CONTENTION_TASK 0x8
EXTERN_C __declspec(selectany) const GUID ContentionId = {0x561410f5, 0xa138, 0x4ab3, {0x94, 0x5e, 0x51, 0x64, 0x83, 0xcd, 0xdf, 0xbc}};
#define CLR_METHOD_TASK 0x9
EXTERN_C __declspec(selectany) const GUID CLRMethodId = {0x3044f61a, 0x99b0, 0x4c21, {0xb2, 0x03, 0xd3, 0x94, 0x23, 0xc7, 0x3b, 0x00}};
#define CLR_LOADER_TASK 0xa
EXTERN_C __declspec(selectany) const GUID CLRLoaderId = {0xd00792da, 0x07b7, 0x40f5, {0x97, 0xeb, 0x5d, 0x97, 0x4e, 0x05, 0x47, 0x40}};
#define CLR_STACK_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};
#define CLR_STRONGNAMEVERIFICATION_TASK 0xc
EXTERN_C __declspec(selectany) const GUID CLRStrongNameVerificationId = {0x15447a14, 0xb523, 0x46ae, {0xb7, 0x5b, 0x02, 0x3f, 0x90, 0x0b, 0x43, 0x93}};
#define CLR_AUTHENTICODEVERIFICATION_TASK 0xd
EXTERN_C __declspec(selectany) const GUID CLRAuthenticodeVerificationId = {0xb17304d9, 0x5afa, 0x4da6, {0x9f, 0x7b, 0x5a, 0x4f, 0xa7, 0x31, 0x29, 0xb6}};
#define CLR_APPDOMAINRESOURCEMANAGEMENT_TASK 0xe
EXTERN_C __declspec(selectany) const GUID AppDomainResourceManagementId = {0x88e83959, 0x6185, 0x4e0b, {0x95, 0xb8, 0x0e, 0x4a, 0x35, 0xdf, 0x61, 0x22}};
#define CLR_IL_STUB 0xf
EXTERN_C __declspec(selectany) const GUID CLRILStubId = {0xd00792da, 0x07b7, 0x40f5, {0x00, 0x00, 0x5d, 0x97, 0x4e, 0x05, 0x47, 0x40}};
#define CLR_THREADPOOLWORKERTHREAD_TASK 0x10
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadId = {0x8a9a44ab, 0xf681, 0x4271, {0x88, 0x10, 0x83, 0x0d, 0xab, 0x9f, 0x56, 0x21}};
#define CLR_THREADPOOLWORKERTHREADRETIREMENT_TASK 0x11
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadRetirementId = {0x402ee399, 0xc137, 0x4dc0, {0xa5, 0xab, 0x3c, 0x2d, 0xea, 0x64, 0xac, 0x9c}};
#define CLR_THREADPOOLWORKERTHREADADJUSTMENT_TASK 0x12
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkerThreadAdjustmentId = {0x94179831, 0xe99a, 0x4625, {0x88, 0x24, 0x23, 0xca, 0x5e, 0x00, 0xca, 0x7d}};
#define CLR_EEStartup_TASK 0x13
EXTERN_C __declspec(selectany) const GUID CLRRuntimeInformationId = {0xcd7d3e32, 0x65fe, 0x40cd, {0x92, 0x25, 0xa2, 0x57, 0x7d, 0x20, 0x3f, 0xc3}};
#define CLR_PERFTRACK_TASK 0x14
EXTERN_C __declspec(selectany) const GUID CLRPerfTrackId = {0xeac685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xec}};
#define CLR_TYPE_TASK 0x15
EXTERN_C __declspec(selectany) const GUID TypeId = {0x003e5a9b, 0x4757, 0x4d3e, {0xb4, 0xa1, 0xe4, 0x7b, 0xfb, 0x48, 0x94, 0x08}};
#define CLR_THREADPOOLWORKINGTHREADCOUNT_TASK 0x16
EXTERN_C __declspec(selectany) const GUID ThreadPoolWorkingThreadCountId = {0x1b032b96, 0x767c, 0x42e4, {0x84, 0x81, 0xcb, 0x52, 0x8a, 0x66, 0xd7, 0xbd}};
#define CLR_THREADPOOL_TASK 0x17
EXTERN_C __declspec(selectany) const GUID ThreadPoolId = {0xead685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xe9}};
#define CLR_THREADING_TASK 0x18
EXTERN_C __declspec(selectany) const GUID ThreadId = {0x641994c5, 0x16f2, 0x4123, {0x91, 0xa7, 0xa2, 0x99, 0x9d, 0xd7, 0xbf, 0xc3}};
#define CLR_DEBUG_IPC_EVENT_TASK 0x19
EXTERN_C __declspec(selectany) const GUID DebugIPCEventId = {0xec2f3703, 0x8321, 0x4301, {0xbd, 0x51, 0x2c, 0xb9, 0xa0, 0x9f, 0x31, 0xb1}};
#define CLR_EXCEPTION_PROCESSING_TASK 0x1a
EXTERN_C __declspec(selectany) const GUID DebugExceptionProcessingId = {0xc4412198, 0xef03, 0x47f1, {0x9b, 0xd1, 0x11, 0xc6, 0x63, 0x7a, 0x20, 0x62}};

//
// Keyword
//
#define CLR_GC_KEYWORD 0x1
#define CLR_GCHANDLE_KEYWORD 0x2
#define CLR_FUSION_KEYWORD 0x4
#define CLR_LOADER_KEYWORD 0x8
#define CLR_JIT_KEYWORD 0x10
#define CLR_NGEN_KEYWORD 0x20
#define CLR_STARTENUMERATION_KEYWORD 0x40
#define CLR_ENDENUMERATION_KEYWORD 0x80
#define CLR_SECURITY_KEYWORD 0x400
#define CLR_APPDOMAINRESOURCEMANAGEMENT_KEYWORD 0x800
#define CLR_JITTRACING_KEYWORD 0x1000
#define CLR_INTEROP_KEYWORD 0x2000
#define CLR_CONTENTION_KEYWORD 0x4000
#define CLR_EXCEPTION_KEYWORD 0x8000
#define CLR_THREADING_KEYWORD 0x10000
#define CLR_JITTEDMETHODILTONATIVEMAP_KEYWORD 0x20000
#define CLR_OVERRIDEANDSUPPRESSNGENEVENTS_KEYWORD 0x40000
#define CLR_TYPE_KEYWORD 0x80000
#define CLR_GCHEAPDUMP_KEYWORD 0x100000
#define CLR_GCHEAPALLOCHIGH_KEYWORD 0x200000
#define CLR_GCHEAPSURVIVALANDMOVEMENT_KEYWORD 0x400000
#define CLR_GCHEAPCOLLECT_KEYWORD 0x800000
#define CLR_GCHEAPANDTYPENAMES_KEYWORD 0x1000000
#define CLR_GCHEAPALLOCLOW_KEYWORD 0x2000000
#define CLR_PERFTRACK_KEYWORD 0x20000000
#define CLR_STACK_KEYWORD 0x40000000
#define CLR_THREADTRANSFER_KEYWORD 0x80000000
#define CLR_DEBUGGER_KEYWORD 0x100000000
#define CLR_MONITORING_KEYWORD 0x200000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart = {0x1, 0x0, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart_V1 = {0x1, 0x1, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_V1_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCStart_V2 = {0x1, 0x2, 0x0, 0x4, 0x1, 0x1, 0x1};
#define GCStart_V2_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCEnd = {0x2, 0x0, 0x0, 0x4, 0x2, 0x1, 0x1};
#define GCEnd_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCEnd_V1 = {0x2, 0x1, 0x0, 0x4, 0x2, 0x1, 0x1};
#define GCEnd_V1_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEEnd = {0x3, 0x0, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCRestartEEEnd_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEEnd_V1 = {0x3, 0x1, 0x0, 0x4, 0x84, 0x1, 0x1};
#define GCRestartEEEnd_V1_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCHeapStats = {0x4, 0x0, 0x0, 0x4, 0x85, 0x1, 0x1};
#define GCHeapStats_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCHeapStats_V1 = {0x4, 0x1, 0x0, 0x4, 0x85, 0x1, 0x1};
#define GCHeapStats_V1_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateSegment = {0x5, 0x0, 0x0, 0x4, 0x86, 0x1, 0x1};
#define GCCreateSegment_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateSegment_V1 = {0x5, 0x1, 0x0, 0x4, 0x86, 0x1, 0x1};
#define GCCreateSegment_V1_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFreeSegment = {0x6, 0x0, 0x0, 0x4, 0x87, 0x1, 0x1};
#define GCFreeSegment_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFreeSegment_V1 = {0x6, 0x1, 0x0, 0x4, 0x87, 0x1, 0x1};
#define GCFreeSegment_V1_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEBegin = {0x7, 0x0, 0x0, 0x4, 0x88, 0x1, 0x1};
#define GCRestartEEBegin_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCRestartEEBegin_V1 = {0x7, 0x1, 0x0, 0x4, 0x88, 0x1, 0x1};
#define GCRestartEEBegin_V1_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEEnd = {0x8, 0x0, 0x0, 0x4, 0x89, 0x1, 0x1};
#define GCSuspendEEEnd_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEEnd_V1 = {0x8, 0x1, 0x0, 0x4, 0x89, 0x1, 0x1};
#define GCSuspendEEEnd_V1_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEBegin = {0x9, 0x0, 0x0, 0x4, 0xa, 0x1, 0x1};
#define GCSuspendEEBegin_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSuspendEEBegin_V1 = {0x9, 0x1, 0x0, 0x4, 0xa, 0x1, 0x1};
#define GCSuspendEEBegin_V1_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick = {0xa, 0x0, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V1 = {0xa, 0x1, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V1_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V2 = {0xa, 0x2, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V2_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCAllocationTick_V3 = {0xa, 0x3, 0x0, 0x5, 0xb, 0x1, 0x1};
#define GCAllocationTick_V3_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateConcurrentThread = {0xb, 0x0, 0x0, 0x4, 0xc, 0x1, 0x1};
#define GCCreateConcurrentThread_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCCreateConcurrentThread_V1 = {0xb, 0x1, 0x0, 0x4, 0xc, 0x1, 0x10001};
#define GCCreateConcurrentThread_V1_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTerminateConcurrentThread = {0xc, 0x0, 0x0, 0x4, 0xd, 0x1, 0x1};
#define GCTerminateConcurrentThread_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTerminateConcurrentThread_V1 = {0xc, 0x1, 0x0, 0x4, 0xd, 0x1, 0x10001};
#define GCTerminateConcurrentThread_V1_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersEnd = {0xd, 0x0, 0x0, 0x4, 0xf, 0x1, 0x1};
#define GCFinalizersEnd_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersEnd_V1 = {0xd, 0x1, 0x0, 0x4, 0xf, 0x1, 0x1};
#define GCFinalizersEnd_V1_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersBegin = {0xe, 0x0, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFinalizersBegin_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCFinalizersBegin_V1 = {0xe, 0x1, 0x0, 0x4, 0x13, 0x1, 0x1};
#define GCFinalizersBegin_V1_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR BulkType = {0xf, 0x0, 0x0, 0x4, 0xa, 0x15, 0x80000};
#define BulkType_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootEdge = {0x10, 0x0, 0x0, 0x4, 0x14, 0x1, 0x100000};
#define GCBulkRootEdge_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootConditionalWeakTableElementEdge = {0x11, 0x0, 0x0, 0x4, 0x15, 0x1, 0x100000};
#define GCBulkRootConditionalWeakTableElementEdge_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkNode = {0x12, 0x0, 0x0, 0x4, 0x16, 0x1, 0x100000};
#define GCBulkNode_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkEdge = {0x13, 0x0, 0x0, 0x4, 0x17, 0x1, 0x100000};
#define GCBulkEdge_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSampledObjectAllocationHigh = {0x14, 0x0, 0x0, 0x4, 0x18, 0x1, 0x200000};
#define GCSampledObjectAllocationHigh_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkSurvivingObjectRanges = {0x15, 0x0, 0x0, 0x4, 0x19, 0x1, 0x400000};
#define GCBulkSurvivingObjectRanges_value 0x15
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkMovedObjectRanges = {0x16, 0x0, 0x0, 0x4, 0x1a, 0x1, 0x400000};
#define GCBulkMovedObjectRanges_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGenerationRange = {0x17, 0x0, 0x0, 0x4, 0x1b, 0x1, 0x400000};
#define GCGenerationRange_value 0x17
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkStackRoots = {0x19, 0x0, 0x0, 0x4, 0x1c, 0x1, 0x1};
#define GCMarkStackRoots_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkFinalizeQueueRoots = {0x1a, 0x0, 0x0, 0x4, 0x1d, 0x1, 0x1};
#define GCMarkFinalizeQueueRoots_value 0x1a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkHandles = {0x1b, 0x0, 0x0, 0x4, 0x1e, 0x1, 0x1};
#define GCMarkHandles_value 0x1b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkOlderGenerationRoots = {0x1c, 0x0, 0x0, 0x4, 0x1f, 0x1, 0x1};
#define GCMarkOlderGenerationRoots_value 0x1c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FinalizeObject = {0x1d, 0x0, 0x0, 0x5, 0x20, 0x1, 0x1};
#define FinalizeObject_value 0x1d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SetGCHandle = {0x1e, 0x0, 0x0, 0x4, 0x21, 0x1, 0x2};
#define SetGCHandle_value 0x1e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DestroyGCHandle = {0x1f, 0x0, 0x0, 0x4, 0x22, 0x1, 0x2};
#define DestroyGCHandle_value 0x1f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCSampledObjectAllocationLow = {0x20, 0x0, 0x0, 0x4, 0x18, 0x1, 0x2000000};
#define GCSampledObjectAllocationLow_value 0x20
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR PinObjectAtGCTime = {0x21, 0x0, 0x0, 0x5, 0x24, 0x1, 0x1};
#define PinObjectAtGCTime_value 0x21
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCTriggered = {0x23, 0x0, 0x0, 0x4, 0x23, 0x1, 0x1};
#define GCTriggered_value 0x23
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootCCW = {0x24, 0x0, 0x0, 0x4, 0x26, 0x1, 0x100000};
#define GCBulkRootCCW_value 0x24
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRCW = {0x25, 0x0, 0x0, 0x4, 0x27, 0x1, 0x100000};
#define GCBulkRCW_value 0x25
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCBulkRootStaticVar = {0x26, 0x0, 0x0, 0x4, 0x28, 0x1, 0x100000};
#define GCBulkRootStaticVar_value 0x26
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCDynamicEvent = {0x27, 0x0, 0x0, 0x0, 0x29, 0x1, 0x3f00003};
#define GCDynamicEvent_value 0x27
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadCreate = {0x28, 0x0, 0x0, 0x4, 0x1, 0x2, 0x10000};
#define WorkerThreadCreate_value 0x28
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadTerminate = {0x29, 0x0, 0x0, 0x4, 0x2, 0x2, 0x10000};
#define WorkerThreadTerminate_value 0x29
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadRetire = {0x2a, 0x0, 0x0, 0x4, 0x1, 0x4, 0x10000};
#define WorkerThreadRetire_value 0x2a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WorkerThreadUnretire = {0x2b, 0x0, 0x0, 0x4, 0x2, 0x4, 0x10000};
#define WorkerThreadUnretire_value 0x2b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadCreate = {0x2c, 0x0, 0x0, 0x4, 0x1, 0x3, 0x10000};
#define IOThreadCreate_value 0x2c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadCreate_V1 = {0x2c, 0x1, 0x0, 0x4, 0x1, 0x3, 0x10000};
#define IOThreadCreate_V1_value 0x2c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadTerminate = {0x2d, 0x0, 0x0, 0x4, 0x2, 0x3, 0x10000};
#define IOThreadTerminate_value 0x2d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadTerminate_V1 = {0x2d, 0x1, 0x0, 0x4, 0x2, 0x3, 0x10000};
#define IOThreadTerminate_V1_value 0x2d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadRetire = {0x2e, 0x0, 0x0, 0x4, 0x1, 0x5, 0x10000};
#define IOThreadRetire_value 0x2e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadRetire_V1 = {0x2e, 0x1, 0x0, 0x4, 0x1, 0x5, 0x10000};
#define IOThreadRetire_V1_value 0x2e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadUnretire = {0x2f, 0x0, 0x0, 0x4, 0x2, 0x5, 0x10000};
#define IOThreadUnretire_value 0x2f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IOThreadUnretire_V1 = {0x2f, 0x1, 0x0, 0x4, 0x2, 0x5, 0x10000};
#define IOThreadUnretire_V1_value 0x2f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadpoolSuspensionSuspendThread = {0x30, 0x0, 0x0, 0x4, 0x1, 0x6, 0x10000};
#define ThreadpoolSuspensionSuspendThread_value 0x30
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadpoolSuspensionResumeThread = {0x31, 0x0, 0x0, 0x4, 0x2, 0x6, 0x10000};
#define ThreadpoolSuspensionResumeThread_value 0x31
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadStart = {0x32, 0x0, 0x0, 0x4, 0x1, 0x10, 0x10000};
#define ThreadPoolWorkerThreadStart_value 0x32
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadStop = {0x33, 0x0, 0x0, 0x4, 0x2, 0x10, 0x10000};
#define ThreadPoolWorkerThreadStop_value 0x33
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadRetirementStart = {0x34, 0x0, 0x0, 0x4, 0x1, 0x11, 0x10000};
#define ThreadPoolWorkerThreadRetirementStart_value 0x34
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadRetirementStop = {0x35, 0x0, 0x0, 0x4, 0x2, 0x11, 0x10000};
#define ThreadPoolWorkerThreadRetirementStop_value 0x35
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentSample = {0x36, 0x0, 0x0, 0x4, 0x64, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentSample_value 0x36
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentAdjustment = {0x37, 0x0, 0x0, 0x4, 0x65, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentAdjustment_value 0x37
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadAdjustmentStats = {0x38, 0x0, 0x0, 0x5, 0x66, 0x12, 0x10000};
#define ThreadPoolWorkerThreadAdjustmentStats_value 0x38
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkerThreadWait = {0x39, 0x0, 0x0, 0x4, 0x5a, 0x10, 0x10000};
#define ThreadPoolWorkerThreadWait_value 0x39
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolWorkingThreadCount = {0x3c, 0x0, 0x0, 0x5, 0x1, 0x16, 0x10000};
#define ThreadPoolWorkingThreadCount_value 0x3c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolEnqueue = {0x3d, 0x0, 0x0, 0x5, 0xb, 0x17, 0x80010000};
#define ThreadPoolEnqueue_value 0x3d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolDequeue = {0x3e, 0x0, 0x0, 0x5, 0xc, 0x17, 0x80010000};
#define ThreadPoolDequeue_value 0x3e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIOEnqueue = {0x3f, 0x0, 0x0, 0x5, 0xd, 0x17, 0x80010000};
#define ThreadPoolIOEnqueue_value 0x3f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIODequeue = {0x40, 0x0, 0x0, 0x5, 0xe, 0x17, 0x80010000};
#define ThreadPoolIODequeue_value 0x40
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadPoolIOPack = {0x41, 0x0, 0x0, 0x5, 0xf, 0x17, 0x10000};
#define ThreadPoolIOPack_value 0x41
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadCreating = {0x46, 0x0, 0x0, 0x4, 0xb, 0x18, 0x80010000};
#define ThreadCreating_value 0x46
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadRunning = {0x47, 0x0, 0x0, 0x4, 0xc, 0x18, 0x80010000};
#define ThreadRunning_value 0x47
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrown = {0x50, 0x0, 0x0, 0x4, 0x1, 0x7, 0x0};
#define ExceptionThrown_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrown_V1 = {0x50, 0x1, 0x0, 0x2, 0x1, 0x7, 0x200008000};
#define ExceptionThrown_V1_value 0x50
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionCatchStart = {0xfa, 0x0, 0x0, 0x4, 0x1, 0x1b, 0x8000};
#define ExceptionCatchStart_value 0xfa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionCatchStop = {0xfb, 0x0, 0x0, 0x4, 0x2, 0x1b, 0x8000};
#define ExceptionCatchStop_value 0xfb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFinallyStart = {0xfc, 0x0, 0x0, 0x4, 0x1, 0x1c, 0x8000};
#define ExceptionFinallyStart_value 0xfc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFinallyStop = {0xfd, 0x0, 0x0, 0x4, 0x2, 0x1c, 0x8000};
#define ExceptionFinallyStop_value 0xfd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFilterStart = {0xfe, 0x0, 0x0, 0x4, 0x1, 0x1d, 0x8000};
#define ExceptionFilterStart_value 0xfe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionFilterStop = {0xff, 0x0, 0x0, 0x4, 0x2, 0x1d, 0x8000};
#define ExceptionFilterStop_value 0xff
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ExceptionThrownStop = {0x100, 0x0, 0x0, 0x4, 0x2, 0x7, 0x8000};
#define ExceptionThrownStop_value 0x100
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Contention = {0x51, 0x0, 0x0, 0x4, 0x1, 0x8, 0x0};
#define Contention_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStart_V1 = {0x51, 0x1, 0x0, 0x4, 0x1, 0x8, 0x4000};
#define ContentionStart_V1_value 0x51
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ContentionStop = {0x5b, 0x0, 0x0, 0x4, 0x2, 0x8, 0x4000};
#define ContentionStop_value 0x5b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalk = {0x52, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalk_value 0x52
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainMemAllocated = {0x53, 0x0, 0x0, 0x4, 0x30, 0xe, 0x800};
#define AppDomainMemAllocated_value 0x53
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainMemSurvived = {0x54, 0x0, 0x0, 0x4, 0x31, 0xe, 0x800};
#define AppDomainMemSurvived_value 0x54
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadCreated = {0x55, 0x0, 0x0, 0x4, 0x32, 0xe, 0x10800};
#define ThreadCreated_value 0x55
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadTerminated = {0x56, 0x0, 0x0, 0x4, 0x33, 0xe, 0x10800};
#define ThreadTerminated_value 0x56
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadDomainEnter = {0x57, 0x0, 0x0, 0x4, 0x34, 0xe, 0x10800};
#define ThreadDomainEnter_value 0x57
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ILStubGenerated = {0x58, 0x0, 0x0, 0x4, 0x58, 0xf, 0x2000};
#define ILStubGenerated_value 0x58
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ILStubCacheHit = {0x59, 0x0, 0x0, 0x4, 0x59, 0xf, 0x2000};
#define ILStubCacheHit_value 0x59
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartCompleteV2 = {0x87, 0x0, 0x0, 0x4, 0xe, 0x9, 0x30};
#define DCStartCompleteV2_value 0x87
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndCompleteV2 = {0x88, 0x0, 0x0, 0x4, 0xf, 0x9, 0x30};
#define DCEndCompleteV2_value 0x88
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartV2 = {0x89, 0x0, 0x0, 0x4, 0x23, 0x9, 0x30};
#define MethodDCStartV2_value 0x89
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndV2 = {0x8a, 0x0, 0x0, 0x4, 0x24, 0x9, 0x30};
#define MethodDCEndV2_value 0x8a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerboseV2 = {0x8b, 0x0, 0x0, 0x4, 0x27, 0x9, 0x30};
#define MethodDCStartVerboseV2_value 0x8b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerboseV2 = {0x8c, 0x0, 0x0, 0x4, 0x28, 0x9, 0x30};
#define MethodDCEndVerboseV2_value 0x8c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad = {0x8d, 0x0, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad_V1 = {0x8d, 0x1, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_V1_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoad_V2 = {0x8d, 0x2, 0x0, 0x4, 0x21, 0x9, 0x30};
#define MethodLoad_V2_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload = {0x8e, 0x0, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload_V1 = {0x8e, 0x1, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_V1_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnload_V2 = {0x8e, 0x2, 0x0, 0x4, 0x22, 0x9, 0x30};
#define MethodUnload_V2_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose = {0x8f, 0x0, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose_V1 = {0x8f, 0x1, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_V1_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodLoadVerbose_V2 = {0x8f, 0x2, 0x0, 0x4, 0x25, 0x9, 0x30};
#define MethodLoadVerbose_V2_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose = {0x90, 0x0, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose_V1 = {0x90, 0x1, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_V1_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodUnloadVerbose_V2 = {0x90, 0x2, 0x0, 0x4, 0x26, 0x9, 0x30};
#define MethodUnloadVerbose_V2_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJittingStarted = {0x91, 0x0, 0x0, 0x5, 0x2a, 0x9, 0x10};
#define MethodJittingStarted_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJittingStarted_V1 = {0x91, 0x1, 0x0, 0x5, 0x2a, 0x9, 0x10};
#define MethodJittingStarted_V1_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitInliningSucceeded = {0xb9, 0x0, 0x0, 0x5, 0x53, 0x9, 0x1000};
#define MethodJitInliningSucceeded_value 0xb9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitInliningFailed = {0xba, 0x0, 0x0, 0x5, 0x54, 0x9, 0x1000};
#define MethodJitInliningFailed_value 0xba
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitTailCallSucceeded = {0xbc, 0x0, 0x0, 0x5, 0x55, 0x9, 0x1000};
#define MethodJitTailCallSucceeded_value 0xbc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodJitTailCallFailed = {0xbd, 0x0, 0x0, 0x5, 0x56, 0x9, 0x1000};
#define MethodJitTailCallFailed_value 0xbd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodILToNativeMap = {0xbe, 0x0, 0x0, 0x5, 0x57, 0x9, 0x20000};
#define MethodILToNativeMap_value 0xbe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStartV2 = {0x95, 0x0, 0x0, 0x4, 0x23, 0xa, 0x8};
#define ModuleDCStartV2_value 0x95
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEndV2 = {0x96, 0x0, 0x0, 0x4, 0x24, 0xa, 0x8};
#define ModuleDCEndV2_value 0x96
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleLoad = {0x97, 0x0, 0x0, 0x4, 0x2d, 0xa, 0x8};
#define DomainModuleLoad_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleLoad_V1 = {0x97, 0x1, 0x0, 0x4, 0x2d, 0xa, 0x8};
#define DomainModuleLoad_V1_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad = {0x98, 0x0, 0x0, 0x4, 0x21, 0xa, 0x8};
#define ModuleLoad_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad_V1 = {0x98, 0x1, 0x0, 0x4, 0x21, 0xa, 0x20000008};
#define ModuleLoad_V1_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleLoad_V2 = {0x98, 0x2, 0x0, 0x4, 0x21, 0xa, 0x20000008};
#define ModuleLoad_V2_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload = {0x99, 0x0, 0x0, 0x4, 0x22, 0xa, 0x8};
#define ModuleUnload_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload_V1 = {0x99, 0x1, 0x0, 0x4, 0x22, 0xa, 0x20000008};
#define ModuleUnload_V1_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleUnload_V2 = {0x99, 0x2, 0x0, 0x4, 0x22, 0xa, 0x20000008};
#define ModuleUnload_V2_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoad = {0x9a, 0x0, 0x0, 0x4, 0x25, 0xa, 0x8};
#define AssemblyLoad_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyLoad_V1 = {0x9a, 0x1, 0x0, 0x4, 0x25, 0xa, 0x8};
#define AssemblyLoad_V1_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyUnload = {0x9b, 0x0, 0x0, 0x4, 0x26, 0xa, 0x8};
#define AssemblyUnload_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyUnload_V1 = {0x9b, 0x1, 0x0, 0x4, 0x26, 0xa, 0x8};
#define AssemblyUnload_V1_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainLoad = {0x9c, 0x0, 0x0, 0x4, 0x29, 0xa, 0x8};
#define AppDomainLoad_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainLoad_V1 = {0x9c, 0x1, 0x0, 0x4, 0x29, 0xa, 0x8};
#define AppDomainLoad_V1_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainUnload = {0x9d, 0x0, 0x0, 0x4, 0x2a, 0xa, 0x8};
#define AppDomainUnload_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainUnload_V1 = {0x9d, 0x1, 0x0, 0x4, 0x2a, 0xa, 0x8};
#define AppDomainUnload_V1_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeLoad = {0x9e, 0x0, 0x0, 0x4, 0xa, 0x14, 0x20000000};
#define ModuleRangeLoad_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStart = {0xb5, 0x0, 0x0, 0x5, 0x1, 0xc, 0x400};
#define StrongNameVerificationStart_value 0xb5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStart_V1 = {0xb5, 0x1, 0x0, 0x5, 0x1, 0xc, 0x400};
#define StrongNameVerificationStart_V1_value 0xb5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStop = {0xb6, 0x0, 0x0, 0x4, 0x2, 0xc, 0x400};
#define StrongNameVerificationStop_value 0xb6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StrongNameVerificationStop_V1 = {0xb6, 0x1, 0x0, 0x4, 0x2, 0xc, 0x400};
#define StrongNameVerificationStop_V1_value 0xb6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStart = {0xb7, 0x0, 0x0, 0x5, 0x1, 0xd, 0x400};
#define AuthenticodeVerificationStart_value 0xb7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStart_V1 = {0xb7, 0x1, 0x0, 0x5, 0x1, 0xd, 0x400};
#define AuthenticodeVerificationStart_V1_value 0xb7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStop = {0xb8, 0x0, 0x0, 0x4, 0x2, 0xd, 0x400};
#define AuthenticodeVerificationStop_value 0xb8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AuthenticodeVerificationStop_V1 = {0xb8, 0x1, 0x0, 0x4, 0x2, 0xd, 0x400};
#define AuthenticodeVerificationStop_V1_value 0xb8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RuntimeInformationStart = {0xbb, 0x0, 0x0, 0x4, 0x1, 0x13, 0x0};
#define RuntimeInformationStart_value 0xbb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR IncreaseMemoryPressure = {0xc8, 0x0, 0x0, 0x5, 0xc8, 0x1, 0x1};
#define IncreaseMemoryPressure_value 0xc8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DecreaseMemoryPressure = {0xc9, 0x0, 0x0, 0x5, 0xc9, 0x1, 0x1};
#define DecreaseMemoryPressure_value 0xc9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCMarkWithType = {0xca, 0x0, 0x0, 0x4, 0xca, 0x1, 0x1};
#define GCMarkWithType_value 0xca
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCJoin_V2 = {0xcb, 0x2, 0x0, 0x5, 0xcb, 0x1, 0x1};
#define GCJoin_V2_value 0xcb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCPerHeapHistory_V3 = {0xcc, 0x3, 0x0, 0x4, 0xcc, 0x1, 0x1};
#define GCPerHeapHistory_V3_value 0xcc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCGlobalHeapHistory_V2 = {0xcd, 0x2, 0x0, 0x4, 0xcd, 0x1, 0x1};
#define GCGlobalHeapHistory_V2_value 0xcd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR GCLoaded = {0xce, 0x0, 0x0, 0x4, 0xce, 0x1, 0x1};
#define GCLoaded_value 0xce
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugIPCEventStart = {0xf0, 0x0, 0x0, 0x4, 0x1, 0x19, 0x100000000};
#define DebugIPCEventStart_value 0xf0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugIPCEventEnd = {0xf1, 0x0, 0x0, 0x4, 0x2, 0x19, 0x100000000};
#define DebugIPCEventEnd_value 0xf1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugExceptionProcessingStart = {0xf2, 0x0, 0x0, 0x4, 0x1, 0x1a, 0x100000000};
#define DebugExceptionProcessingStart_value 0xf2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DebugExceptionProcessingEnd = {0xf3, 0x0, 0x0, 0x4, 0x2, 0x1a, 0x100000000};
#define DebugExceptionProcessingEnd_value 0xf3

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimeEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimeKeywords[32] = {0x1, 0x1, 0x10001, 0x80000, 0x100000, 0x200000, 0x400000, 0x2, 0x2000000, 0x3f00003, 0x10000, 0x10000, 0x80010000, 0x80010000, 0x0, 0x200008000, 0x8000, 0x4000, 0x40000000, 0x800, 0x10800, 0x2000, 0x30, 0x10, 0x1000, 0x20000, 0x8, 0x20000008, 0x20000000, 0x400, 0x400, 0x100000000};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimeLevels[32] = {4, 5, 4, 4, 4, 4, 4, 4, 4, 0, 4, 5, 5, 4, 4, 2, 4, 4, 0, 4, 4, 4, 4, 5, 5, 5, 4, 4, 4, 5, 4, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 32, Microsoft_Windows_DotNETRuntimeEnableBits, Microsoft_Windows_DotNETRuntimeKeywords, Microsoft_Windows_DotNETRuntimeLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimeHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntime
#define EventRegisterMicrosoft_Windows_DotNETRuntime() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntime
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntime(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntime
#define EventUnregisterMicrosoft_Windows_DotNETRuntime() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimeHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntime));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntime {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimeHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_Windows_DotNETRuntime;

#define EventRegisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntime_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntime_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimeHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntime_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntime* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 32;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimeKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimeLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntime*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(_In_ McGenContext_Microsoft_Windows_DotNETRuntime* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "GCStart"
//
#define EventEnabledGCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart"
//
#define EventWriteGCStart(Count, Reason) \
        MCGEN_EVENT_ENABLED(GCStart) \
        ? _mcgen_TEMPLATE_FOR_GCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart, Count, Reason) : 0
#define EventWriteGCStart_AssumeEnabled(Count, Reason) \
        _mcgen_TEMPLATE_FOR_GCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart, Count, Reason)
#define EventWriteGCStart_ForContext(pContext, Count, Reason) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart) \
        ? _mcgen_TEMPLATE_FOR_GCStart(&(pContext)->Context, &GCStart, Count, Reason) : 0
#define EventWriteGCStart_ForContextAssumeEnabled(pContext, Count, Reason) \
        _mcgen_TEMPLATE_FOR_GCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart, Count, Reason)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCStart_V1"
//
#define EventEnabledGCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart_V1"
//
#define EventWriteGCStart_V1(Count, Depth, Reason, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID) : 0
#define EventWriteGCStart_V1_AssumeEnabled(Count, Depth, Reason, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID)
#define EventWriteGCStart_V1_ForContext(pContext, Count, Depth, Reason, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V1(&(pContext)->Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID) : 0
#define EventWriteGCStart_V1_ForContextAssumeEnabled(pContext, Count, Depth, Reason, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart_V1, Count, Depth, Reason, Type, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart_V1 _mcgen_PASTE2(McTemplateU0qqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCStart_V2"
//
#define EventEnabledGCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCStart_V2"
//
#define EventWriteGCStart_V2(Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        MCGEN_EVENT_ENABLED(GCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) : 0
#define EventWriteGCStart_V2_AssumeEnabled(Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        _mcgen_TEMPLATE_FOR_GCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber)
#define EventWriteGCStart_V2_ForContext(pContext, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_GCStart_V2(&(pContext)->Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) : 0
#define EventWriteGCStart_V2_ForContextAssumeEnabled(pContext, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber) \
        _mcgen_TEMPLATE_FOR_GCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCStart_V2, Count, Depth, Reason, Type, ClrInstanceID, ClientSequenceNumber)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCStart_V2 _mcgen_PASTE2(McTemplateU0qqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCEnd"
//
#define EventEnabledGCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCEnd"
//
#define EventWriteGCEnd(Count, Depth) \
        MCGEN_EVENT_ENABLED(GCEnd) \
        ? _mcgen_TEMPLATE_FOR_GCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd, Count, Depth) : 0
#define EventWriteGCEnd_AssumeEnabled(Count, Depth) \
        _mcgen_TEMPLATE_FOR_GCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd, Count, Depth)
#define EventWriteGCEnd_ForContext(pContext, Count, Depth) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCEnd) \
        ? _mcgen_TEMPLATE_FOR_GCEnd(&(pContext)->Context, &GCEnd, Count, Depth) : 0
#define EventWriteGCEnd_ForContextAssumeEnabled(pContext, Count, Depth) \
        _mcgen_TEMPLATE_FOR_GCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCEnd, Count, Depth)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCEnd _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCEnd_V1"
//
#define EventEnabledGCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCEnd_V1"
//
#define EventWriteGCEnd_V1(Count, Depth, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd_V1, Count, Depth, ClrInstanceID) : 0
#define EventWriteGCEnd_V1_AssumeEnabled(Count, Depth, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCEnd_V1, Count, Depth, ClrInstanceID)
#define EventWriteGCEnd_V1_ForContext(pContext, Count, Depth, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCEnd_V1(&(pContext)->Context, &GCEnd_V1, Count, Depth, ClrInstanceID) : 0
#define EventWriteGCEnd_V1_ForContextAssumeEnabled(pContext, Count, Depth, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCEnd_V1, Count, Depth, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCEnd_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEEnd"
//
#define EventEnabledGCRestartEEEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCRestartEEEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEEnd"
//
#define EventWriteGCRestartEEEnd() \
        MCGEN_EVENT_ENABLED(GCRestartEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd) : 0
#define EventWriteGCRestartEEEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd)
#define EventWriteGCRestartEEEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&(pContext)->Context, &GCRestartEEEnd) : 0
#define EventWriteGCRestartEEEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEEnd _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEEnd_V1"
//
#define EventEnabledGCRestartEEEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCRestartEEEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEEnd_V1"
//
#define EventWriteGCRestartEEEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCRestartEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd_V1, ClrInstanceID) : 0
#define EventWriteGCRestartEEEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEEnd_V1, ClrInstanceID)
#define EventWriteGCRestartEEEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&(pContext)->Context, &GCRestartEEEnd_V1, ClrInstanceID) : 0
#define EventWriteGCRestartEEEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEEnd_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCHeapStats"
//
#define EventEnabledGCHeapStats() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCHeapStats_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCHeapStats"
//
#define EventWriteGCHeapStats(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        MCGEN_EVENT_ENABLED(GCHeapStats) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) : 0
#define EventWriteGCHeapStats_AssumeEnabled(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        _mcgen_TEMPLATE_FOR_GCHeapStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount)
#define EventWriteGCHeapStats_ForContext(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCHeapStats) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats(&(pContext)->Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) : 0
#define EventWriteGCHeapStats_ForContextAssumeEnabled(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount) \
        _mcgen_TEMPLATE_FOR_GCHeapStats(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCHeapStats, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCHeapStats _mcgen_PASTE2(McTemplateU0xxxxxxxxxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCHeapStats_V1"
//
#define EventEnabledGCHeapStats_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCHeapStats_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCHeapStats_V1"
//
#define EventWriteGCHeapStats_V1(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCHeapStats_V1) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) : 0
#define EventWriteGCHeapStats_V1_AssumeEnabled(GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID)
#define EventWriteGCHeapStats_V1_ForContext(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCHeapStats_V1) \
        ? _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&(pContext)->Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) : 0
#define EventWriteGCHeapStats_V1_ForContextAssumeEnabled(pContext, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCHeapStats_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCHeapStats_V1, GenerationSize0, TotalPromotedSize0, GenerationSize1, TotalPromotedSize1, GenerationSize2, TotalPromotedSize2, GenerationSize3, TotalPromotedSize3, FinalizationPromotedSize, FinalizationPromotedCount, PinnedObjectCount, SinkBlockCount, GCHandleCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCHeapStats_V1 _mcgen_PASTE2(McTemplateU0xxxxxxxxxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateSegment"
//
#define EventEnabledGCCreateSegment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCCreateSegment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateSegment"
//
#define EventWriteGCCreateSegment(Address, Size, Type) \
        MCGEN_EVENT_ENABLED(GCCreateSegment) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment, Address, Size, Type) : 0
#define EventWriteGCCreateSegment_AssumeEnabled(Address, Size, Type) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment, Address, Size, Type)
#define EventWriteGCCreateSegment_ForContext(pContext, Address, Size, Type) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateSegment) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment(&(pContext)->Context, &GCCreateSegment, Address, Size, Type) : 0
#define EventWriteGCCreateSegment_ForContextAssumeEnabled(pContext, Address, Size, Type) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateSegment, Address, Size, Type)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateSegment _mcgen_PASTE2(McTemplateU0xxq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateSegment_V1"
//
#define EventEnabledGCCreateSegment_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCCreateSegment_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateSegment_V1"
//
#define EventWriteGCCreateSegment_V1(Address, Size, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCCreateSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID) : 0
#define EventWriteGCCreateSegment_V1_AssumeEnabled(Address, Size, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID)
#define EventWriteGCCreateSegment_V1_ForContext(pContext, Address, Size, Type, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&(pContext)->Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID) : 0
#define EventWriteGCCreateSegment_V1_ForContextAssumeEnabled(pContext, Address, Size, Type, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateSegment_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateSegment_V1, Address, Size, Type, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateSegment_V1 _mcgen_PASTE2(McTemplateU0xxqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFreeSegment"
//
#define EventEnabledGCFreeSegment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFreeSegment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFreeSegment"
//
#define EventWriteGCFreeSegment(Address) \
        MCGEN_EVENT_ENABLED(GCFreeSegment) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment, Address) : 0
#define EventWriteGCFreeSegment_AssumeEnabled(Address) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment, Address)
#define EventWriteGCFreeSegment_ForContext(pContext, Address) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFreeSegment) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment(&(pContext)->Context, &GCFreeSegment, Address) : 0
#define EventWriteGCFreeSegment_ForContextAssumeEnabled(pContext, Address) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFreeSegment, Address)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFreeSegment _mcgen_PASTE2(McTemplateU0x_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFreeSegment_V1"
//
#define EventEnabledGCFreeSegment_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFreeSegment_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFreeSegment_V1"
//
#define EventWriteGCFreeSegment_V1(Address, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFreeSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment_V1, Address, ClrInstanceID) : 0
#define EventWriteGCFreeSegment_V1_AssumeEnabled(Address, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFreeSegment_V1, Address, ClrInstanceID)
#define EventWriteGCFreeSegment_V1_ForContext(pContext, Address, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFreeSegment_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&(pContext)->Context, &GCFreeSegment_V1, Address, ClrInstanceID) : 0
#define EventWriteGCFreeSegment_V1_ForContextAssumeEnabled(pContext, Address, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFreeSegment_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFreeSegment_V1, Address, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFreeSegment_V1 _mcgen_PASTE2(McTemplateU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEBegin"
//
#define EventEnabledGCRestartEEBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCRestartEEBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEBegin"
//
#define EventWriteGCRestartEEBegin() \
        MCGEN_EVENT_ENABLED(GCRestartEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin) : 0
#define EventWriteGCRestartEEBegin_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin)
#define EventWriteGCRestartEEBegin_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&(pContext)->Context, &GCRestartEEBegin) : 0
#define EventWriteGCRestartEEBegin_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEBegin)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEBegin _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCRestartEEBegin_V1"
//
#define EventEnabledGCRestartEEBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCRestartEEBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCRestartEEBegin_V1"
//
#define EventWriteGCRestartEEBegin_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCRestartEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin_V1, ClrInstanceID) : 0
#define EventWriteGCRestartEEBegin_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCRestartEEBegin_V1, ClrInstanceID)
#define EventWriteGCRestartEEBegin_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCRestartEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&(pContext)->Context, &GCRestartEEBegin_V1, ClrInstanceID) : 0
#define EventWriteGCRestartEEBegin_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCRestartEEBegin_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCRestartEEBegin_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEEnd"
//
#define EventEnabledGCSuspendEEEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCSuspendEEEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEEnd"
//
#define EventWriteGCSuspendEEEnd() \
        MCGEN_EVENT_ENABLED(GCSuspendEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd) : 0
#define EventWriteGCSuspendEEEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd)
#define EventWriteGCSuspendEEEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEEnd) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&(pContext)->Context, &GCSuspendEEEnd) : 0
#define EventWriteGCSuspendEEEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEEnd _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEEnd_V1"
//
#define EventEnabledGCSuspendEEEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCSuspendEEEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEEnd_V1"
//
#define EventWriteGCSuspendEEEnd_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSuspendEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd_V1, ClrInstanceID) : 0
#define EventWriteGCSuspendEEEnd_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEEnd_V1, ClrInstanceID)
#define EventWriteGCSuspendEEEnd_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&(pContext)->Context, &GCSuspendEEEnd_V1, ClrInstanceID) : 0
#define EventWriteGCSuspendEEEnd_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEEnd_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEEnd_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEBegin"
//
#define EventEnabledGCSuspendEEBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCSuspendEEBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEBegin"
//
#define EventWriteGCSuspendEEBegin(Reason) \
        MCGEN_EVENT_ENABLED(GCSuspendEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin, Reason) : 0
#define EventWriteGCSuspendEEBegin_AssumeEnabled(Reason) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin, Reason)
#define EventWriteGCSuspendEEBegin_ForContext(pContext, Reason) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEBegin) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&(pContext)->Context, &GCSuspendEEBegin, Reason) : 0
#define EventWriteGCSuspendEEBegin_ForContextAssumeEnabled(pContext, Reason) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEBegin, Reason)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEBegin _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSuspendEEBegin_V1"
//
#define EventEnabledGCSuspendEEBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCSuspendEEBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCSuspendEEBegin_V1"
//
#define EventWriteGCSuspendEEBegin_V1(Reason, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSuspendEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID) : 0
#define EventWriteGCSuspendEEBegin_V1_AssumeEnabled(Reason, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID)
#define EventWriteGCSuspendEEBegin_V1_ForContext(pContext, Reason, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSuspendEEBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&(pContext)->Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID) : 0
#define EventWriteGCSuspendEEBegin_V1_ForContextAssumeEnabled(pContext, Reason, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSuspendEEBegin_V1, Reason, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSuspendEEBegin_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick"
//
#define EventEnabledGCAllocationTick() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledGCAllocationTick_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick"
//
#define EventWriteGCAllocationTick(AllocationAmount, AllocationKind) \
        MCGEN_EVENT_ENABLED(GCAllocationTick) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick, AllocationAmount, AllocationKind) : 0
#define EventWriteGCAllocationTick_AssumeEnabled(AllocationAmount, AllocationKind) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick, AllocationAmount, AllocationKind)
#define EventWriteGCAllocationTick_ForContext(pContext, AllocationAmount, AllocationKind) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick(&(pContext)->Context, &GCAllocationTick, AllocationAmount, AllocationKind) : 0
#define EventWriteGCAllocationTick_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick, AllocationAmount, AllocationKind)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V1"
//
#define EventEnabledGCAllocationTick_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledGCAllocationTick_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V1"
//
#define EventWriteGCAllocationTick_V1(AllocationAmount, AllocationKind, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V1) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID) : 0
#define EventWriteGCAllocationTick_V1_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID)
#define EventWriteGCAllocationTick_V1_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V1) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&(pContext)->Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID) : 0
#define EventWriteGCAllocationTick_V1_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V1, AllocationAmount, AllocationKind, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V2"
//
#define EventEnabledGCAllocationTick_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledGCAllocationTick_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V2"
//
#define EventWriteGCAllocationTick_V2(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V2) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) : 0
#define EventWriteGCAllocationTick_V2_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex)
#define EventWriteGCAllocationTick_V2_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V2) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&(pContext)->Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) : 0
#define EventWriteGCAllocationTick_V2_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V2, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V2 _mcgen_PASTE2(McTemplateU0qqhxpzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCAllocationTick_V3"
//
#define EventEnabledGCAllocationTick_V3() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledGCAllocationTick_V3_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCAllocationTick_V3"
//
#define EventWriteGCAllocationTick_V3(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        MCGEN_EVENT_ENABLED(GCAllocationTick_V3) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) : 0
#define EventWriteGCAllocationTick_V3_AssumeEnabled(AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address)
#define EventWriteGCAllocationTick_V3_ForContext(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCAllocationTick_V3) \
        ? _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&(pContext)->Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) : 0
#define EventWriteGCAllocationTick_V3_ForContextAssumeEnabled(pContext, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address) \
        _mcgen_TEMPLATE_FOR_GCAllocationTick_V3(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCAllocationTick_V3, AllocationAmount, AllocationKind, ClrInstanceID, AllocationAmount64, TypeID, TypeName, HeapIndex, Address)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCAllocationTick_V3 _mcgen_PASTE2(McTemplateU0qqhxpzqp_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateConcurrentThread"
//
#define EventEnabledGCCreateConcurrentThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCCreateConcurrentThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCCreateConcurrentThread"
//
#define EventWriteGCCreateConcurrentThread() \
        MCGEN_EVENT_ENABLED(GCCreateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread) : 0
#define EventWriteGCCreateConcurrentThread_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread)
#define EventWriteGCCreateConcurrentThread_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&(pContext)->Context, &GCCreateConcurrentThread) : 0
#define EventWriteGCCreateConcurrentThread_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateConcurrentThread)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCCreateConcurrentThread_V1"
//
#define EventEnabledGCCreateConcurrentThread_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 2)
#define EventEnabledGCCreateConcurrentThread_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 2)

//
// Event write macros for event "GCCreateConcurrentThread_V1"
//
#define EventWriteGCCreateConcurrentThread_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCCreateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread_V1, ClrInstanceID) : 0
#define EventWriteGCCreateConcurrentThread_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCCreateConcurrentThread_V1, ClrInstanceID)
#define EventWriteGCCreateConcurrentThread_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCCreateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&(pContext)->Context, &GCCreateConcurrentThread_V1, ClrInstanceID) : 0
#define EventWriteGCCreateConcurrentThread_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCCreateConcurrentThread_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCCreateConcurrentThread_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTerminateConcurrentThread"
//
#define EventEnabledGCTerminateConcurrentThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCTerminateConcurrentThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCTerminateConcurrentThread"
//
#define EventWriteGCTerminateConcurrentThread() \
        MCGEN_EVENT_ENABLED(GCTerminateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread) : 0
#define EventWriteGCTerminateConcurrentThread_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread)
#define EventWriteGCTerminateConcurrentThread_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTerminateConcurrentThread) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&(pContext)->Context, &GCTerminateConcurrentThread) : 0
#define EventWriteGCTerminateConcurrentThread_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTerminateConcurrentThread)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTerminateConcurrentThread_V1"
//
#define EventEnabledGCTerminateConcurrentThread_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 2)
#define EventEnabledGCTerminateConcurrentThread_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 2)

//
// Event write macros for event "GCTerminateConcurrentThread_V1"
//
#define EventWriteGCTerminateConcurrentThread_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCTerminateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread_V1, ClrInstanceID) : 0
#define EventWriteGCTerminateConcurrentThread_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTerminateConcurrentThread_V1, ClrInstanceID)
#define EventWriteGCTerminateConcurrentThread_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTerminateConcurrentThread_V1) \
        ? _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&(pContext)->Context, &GCTerminateConcurrentThread_V1, ClrInstanceID) : 0
#define EventWriteGCTerminateConcurrentThread_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTerminateConcurrentThread_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTerminateConcurrentThread_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersEnd"
//
#define EventEnabledGCFinalizersEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFinalizersEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersEnd"
//
#define EventWriteGCFinalizersEnd(Count) \
        MCGEN_EVENT_ENABLED(GCFinalizersEnd) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd, Count) : 0
#define EventWriteGCFinalizersEnd_AssumeEnabled(Count) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd, Count)
#define EventWriteGCFinalizersEnd_ForContext(pContext, Count) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersEnd) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&(pContext)->Context, &GCFinalizersEnd, Count) : 0
#define EventWriteGCFinalizersEnd_ForContextAssumeEnabled(pContext, Count) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersEnd, Count)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersEnd _mcgen_PASTE2(McTemplateU0q_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersEnd_V1"
//
#define EventEnabledGCFinalizersEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFinalizersEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersEnd_V1"
//
#define EventWriteGCFinalizersEnd_V1(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFinalizersEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd_V1, Count, ClrInstanceID) : 0
#define EventWriteGCFinalizersEnd_V1_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersEnd_V1, Count, ClrInstanceID)
#define EventWriteGCFinalizersEnd_V1_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&(pContext)->Context, &GCFinalizersEnd_V1, Count, ClrInstanceID) : 0
#define EventWriteGCFinalizersEnd_V1_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersEnd_V1, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersEnd_V1 _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersBegin"
//
#define EventEnabledGCFinalizersBegin() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFinalizersBegin_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersBegin"
//
#define EventWriteGCFinalizersBegin() \
        MCGEN_EVENT_ENABLED(GCFinalizersBegin) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin) : 0
#define EventWriteGCFinalizersBegin_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin)
#define EventWriteGCFinalizersBegin_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersBegin) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&(pContext)->Context, &GCFinalizersBegin) : 0
#define EventWriteGCFinalizersBegin_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersBegin)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersBegin _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCFinalizersBegin_V1"
//
#define EventEnabledGCFinalizersBegin_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCFinalizersBegin_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCFinalizersBegin_V1"
//
#define EventWriteGCFinalizersBegin_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCFinalizersBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin_V1, ClrInstanceID) : 0
#define EventWriteGCFinalizersBegin_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCFinalizersBegin_V1, ClrInstanceID)
#define EventWriteGCFinalizersBegin_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCFinalizersBegin_V1) \
        ? _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&(pContext)->Context, &GCFinalizersBegin_V1, ClrInstanceID) : 0
#define EventWriteGCFinalizersBegin_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCFinalizersBegin_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCFinalizersBegin_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "BulkType"
//
#define EventEnabledBulkType() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 3)
#define EventEnabledBulkType_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 3)

//
// Event write macros for event "BulkType"
//
#define EventWriteBulkType(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(BulkType) \
        ? _mcgen_TEMPLATE_FOR_BulkType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteBulkType_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_BulkType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteBulkType_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, BulkType) \
        ? _mcgen_TEMPLATE_FOR_BulkType(&(pContext)->Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteBulkType_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_BulkType(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &BulkType, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_BulkType _mcgen_PASTE2(McTemplateU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootEdge"
//
#define EventEnabledGCBulkRootEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkRootEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootEdge"
//
#define EventWriteGCBulkRootEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkRootEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&(pContext)->Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootEdge _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootConditionalWeakTableElementEdge"
//
#define EventEnabledGCBulkRootConditionalWeakTableElementEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkRootConditionalWeakTableElementEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootConditionalWeakTableElementEdge"
//
#define EventWriteGCBulkRootConditionalWeakTableElementEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootConditionalWeakTableElementEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootConditionalWeakTableElementEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkRootConditionalWeakTableElementEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootConditionalWeakTableElementEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&(pContext)->Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootConditionalWeakTableElementEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootConditionalWeakTableElementEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootConditionalWeakTableElementEdge _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkNode"
//
#define EventEnabledGCBulkNode() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkNode_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkNode"
//
#define EventWriteGCBulkNode(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkNode) \
        ? _mcgen_TEMPLATE_FOR_GCBulkNode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkNode_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkNode(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkNode_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkNode) \
        ? _mcgen_TEMPLATE_FOR_GCBulkNode(&(pContext)->Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkNode_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkNode(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkNode, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkNode _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkEdge"
//
#define EventEnabledGCBulkEdge() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkEdge_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkEdge"
//
#define EventWriteGCBulkEdge(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkEdge_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkEdge(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkEdge_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkEdge) \
        ? _mcgen_TEMPLATE_FOR_GCBulkEdge(&(pContext)->Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkEdge_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkEdge(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkEdge, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkEdge _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSampledObjectAllocationHigh"
//
#define EventEnabledGCSampledObjectAllocationHigh() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 5)
#define EventEnabledGCSampledObjectAllocationHigh_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 5)

//
// Event write macros for event "GCSampledObjectAllocationHigh"
//
#define EventWriteGCSampledObjectAllocationHigh(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSampledObjectAllocationHigh) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define EventWriteGCSampledObjectAllocationHigh_AssumeEnabled(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)
#define EventWriteGCSampledObjectAllocationHigh_ForContext(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSampledObjectAllocationHigh) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&(pContext)->Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define EventWriteGCSampledObjectAllocationHigh_ForContextAssumeEnabled(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSampledObjectAllocationHigh, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationHigh _mcgen_PASTE2(McTemplateU0ppqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkSurvivingObjectRanges"
//
#define EventEnabledGCBulkSurvivingObjectRanges() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventEnabledGCBulkSurvivingObjectRanges_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCBulkSurvivingObjectRanges"
//
#define EventWriteGCBulkSurvivingObjectRanges(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkSurvivingObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkSurvivingObjectRanges_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkSurvivingObjectRanges_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkSurvivingObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&(pContext)->Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkSurvivingObjectRanges_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkSurvivingObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkSurvivingObjectRanges _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkMovedObjectRanges"
//
#define EventEnabledGCBulkMovedObjectRanges() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventEnabledGCBulkMovedObjectRanges_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCBulkMovedObjectRanges"
//
#define EventWriteGCBulkMovedObjectRanges(Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkMovedObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkMovedObjectRanges_AssumeEnabled(Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkMovedObjectRanges_ForContext(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkMovedObjectRanges) \
        ? _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&(pContext)->Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkMovedObjectRanges_ForContextAssumeEnabled(pContext, Index, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkMovedObjectRanges, Index, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkMovedObjectRanges _mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGenerationRange"
//
#define EventEnabledGCGenerationRange() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 6)
#define EventEnabledGCGenerationRange_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 6)

//
// Event write macros for event "GCGenerationRange"
//
#define EventWriteGCGenerationRange(Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCGenerationRange) \
        ? _mcgen_TEMPLATE_FOR_GCGenerationRange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) : 0
#define EventWriteGCGenerationRange_AssumeEnabled(Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGenerationRange(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID)
#define EventWriteGCGenerationRange_ForContext(pContext, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGenerationRange) \
        ? _mcgen_TEMPLATE_FOR_GCGenerationRange(&(pContext)->Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) : 0
#define EventWriteGCGenerationRange_ForContextAssumeEnabled(pContext, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCGenerationRange(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGenerationRange, Generation, RangeStart, RangeUsedLength, RangeReservedLength, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGenerationRange _mcgen_PASTE2(McTemplateU0upxxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkStackRoots"
//
#define EventEnabledGCMarkStackRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCMarkStackRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkStackRoots"
//
#define EventWriteGCMarkStackRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkStackRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkStackRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkStackRoots, HeapNum, ClrInstanceID)
#define EventWriteGCMarkStackRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkStackRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&(pContext)->Context, &GCMarkStackRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkStackRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkStackRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkStackRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkStackRoots _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkFinalizeQueueRoots"
//
#define EventEnabledGCMarkFinalizeQueueRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCMarkFinalizeQueueRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkFinalizeQueueRoots"
//
#define EventWriteGCMarkFinalizeQueueRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkFinalizeQueueRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID)
#define EventWriteGCMarkFinalizeQueueRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkFinalizeQueueRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&(pContext)->Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkFinalizeQueueRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkFinalizeQueueRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkFinalizeQueueRoots _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkHandles"
//
#define EventEnabledGCMarkHandles() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCMarkHandles_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkHandles"
//
#define EventWriteGCMarkHandles(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_GCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkHandles, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkHandles_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkHandles(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkHandles, HeapNum, ClrInstanceID)
#define EventWriteGCMarkHandles_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkHandles) \
        ? _mcgen_TEMPLATE_FOR_GCMarkHandles(&(pContext)->Context, &GCMarkHandles, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkHandles_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkHandles(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkHandles, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkHandles _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkOlderGenerationRoots"
//
#define EventEnabledGCMarkOlderGenerationRoots() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCMarkOlderGenerationRoots_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkOlderGenerationRoots"
//
#define EventWriteGCMarkOlderGenerationRoots(HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCMarkOlderGenerationRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkOlderGenerationRoots_AssumeEnabled(HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID)
#define EventWriteGCMarkOlderGenerationRoots_ForContext(pContext, HeapNum, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkOlderGenerationRoots) \
        ? _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&(pContext)->Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID) : 0
#define EventWriteGCMarkOlderGenerationRoots_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkOlderGenerationRoots, HeapNum, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkOlderGenerationRoots _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FinalizeObject"
//
#define EventEnabledFinalizeObject() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledFinalizeObject_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "FinalizeObject"
//
#define EventWriteFinalizeObject(TypeID, ObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(FinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_FinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID) : 0
#define EventWriteFinalizeObject_AssumeEnabled(TypeID, ObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FinalizeObject(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID)
#define EventWriteFinalizeObject_ForContext(pContext, TypeID, ObjectID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FinalizeObject) \
        ? _mcgen_TEMPLATE_FOR_FinalizeObject(&(pContext)->Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID) : 0
#define EventWriteFinalizeObject_ForContextAssumeEnabled(pContext, TypeID, ObjectID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_FinalizeObject(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &FinalizeObject, TypeID, ObjectID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FinalizeObject _mcgen_PASTE2(McTemplateU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SetGCHandle"
//
#define EventEnabledSetGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 7)
#define EventEnabledSetGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 7)

//
// Event write macros for event "SetGCHandle"
//
#define EventWriteSetGCHandle(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(SetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_SetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define EventWriteSetGCHandle_AssumeEnabled(HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SetGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)
#define EventWriteSetGCHandle_ForContext(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SetGCHandle) \
        ? _mcgen_TEMPLATE_FOR_SetGCHandle(&(pContext)->Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) : 0
#define EventWriteSetGCHandle_ForContextAssumeEnabled(pContext, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_SetGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &SetGCHandle, HandleID, ObjectID, Kind, Generation, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SetGCHandle _mcgen_PASTE2(McTemplateU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DestroyGCHandle"
//
#define EventEnabledDestroyGCHandle() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 7)
#define EventEnabledDestroyGCHandle_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 7)

//
// Event write macros for event "DestroyGCHandle"
//
#define EventWriteDestroyGCHandle(HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_DestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DestroyGCHandle, HandleID, ClrInstanceID) : 0
#define EventWriteDestroyGCHandle_AssumeEnabled(HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DestroyGCHandle(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DestroyGCHandle, HandleID, ClrInstanceID)
#define EventWriteDestroyGCHandle_ForContext(pContext, HandleID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DestroyGCHandle) \
        ? _mcgen_TEMPLATE_FOR_DestroyGCHandle(&(pContext)->Context, &DestroyGCHandle, HandleID, ClrInstanceID) : 0
#define EventWriteDestroyGCHandle_ForContextAssumeEnabled(pContext, HandleID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DestroyGCHandle(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DestroyGCHandle, HandleID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DestroyGCHandle _mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCSampledObjectAllocationLow"
//
#define EventEnabledGCSampledObjectAllocationLow() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 8)
#define EventEnabledGCSampledObjectAllocationLow_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 8)

//
// Event write macros for event "GCSampledObjectAllocationLow"
//
#define EventWriteGCSampledObjectAllocationLow(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCSampledObjectAllocationLow) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define EventWriteGCSampledObjectAllocationLow_AssumeEnabled(Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)
#define EventWriteGCSampledObjectAllocationLow_ForContext(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCSampledObjectAllocationLow) \
        ? _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&(pContext)->Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) : 0
#define EventWriteGCSampledObjectAllocationLow_ForContextAssumeEnabled(pContext, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCSampledObjectAllocationLow, Address, TypeID, ObjectCountForTypeSample, TotalSizeForTypeSample, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCSampledObjectAllocationLow _mcgen_PASTE2(McTemplateU0ppqxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "PinObjectAtGCTime"
//
#define EventEnabledPinObjectAtGCTime() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledPinObjectAtGCTime_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "PinObjectAtGCTime"
//
#define EventWritePinObjectAtGCTime(HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(PinObjectAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) : 0
#define EventWritePinObjectAtGCTime_AssumeEnabled(HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID)
#define EventWritePinObjectAtGCTime_ForContext(pContext, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, PinObjectAtGCTime) \
        ? _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&(pContext)->Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) : 0
#define EventWritePinObjectAtGCTime_ForContextAssumeEnabled(pContext, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_PinObjectAtGCTime(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &PinObjectAtGCTime, HandleID, ObjectID, ObjectSize, TypeName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_PinObjectAtGCTime _mcgen_PASTE2(McTemplateU0ppxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCTriggered"
//
#define EventEnabledGCTriggered() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCTriggered_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCTriggered"
//
#define EventWriteGCTriggered(Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCTriggered) \
        ? _mcgen_TEMPLATE_FOR_GCTriggered(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTriggered, Reason, ClrInstanceID) : 0
#define EventWriteGCTriggered_AssumeEnabled(Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTriggered(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCTriggered, Reason, ClrInstanceID)
#define EventWriteGCTriggered_ForContext(pContext, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCTriggered) \
        ? _mcgen_TEMPLATE_FOR_GCTriggered(&(pContext)->Context, &GCTriggered, Reason, ClrInstanceID) : 0
#define EventWriteGCTriggered_ForContextAssumeEnabled(pContext, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCTriggered(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCTriggered, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCTriggered _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootCCW"
//
#define EventEnabledGCBulkRootCCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkRootCCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootCCW"
//
#define EventWriteGCBulkRootCCW(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootCCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootCCW_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkRootCCW_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootCCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&(pContext)->Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootCCW_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootCCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootCCW, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootCCW _mcgen_PASTE2(McTemplateU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRCW"
//
#define EventEnabledGCBulkRCW() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkRCW_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRCW"
//
#define EventWriteGCBulkRCW(Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRCW_AssumeEnabled(Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRCW(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkRCW_ForContext(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRCW) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRCW(&(pContext)->Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRCW_ForContextAssumeEnabled(pContext, Count, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRCW(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRCW, Count, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRCW _mcgen_PASTE2(McTemplateU0qhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCBulkRootStaticVar"
//
#define EventEnabledGCBulkRootStaticVar() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 4)
#define EventEnabledGCBulkRootStaticVar_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 4)

//
// Event write macros for event "GCBulkRootStaticVar"
//
#define EventWriteGCBulkRootStaticVar(Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCBulkRootStaticVar) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootStaticVar_AssumeEnabled(Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values)
#define EventWriteGCBulkRootStaticVar_ForContext(pContext, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCBulkRootStaticVar) \
        ? _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&(pContext)->Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) : 0
#define EventWriteGCBulkRootStaticVar_ForContextAssumeEnabled(pContext, Count, AppDomainID, ClrInstanceID, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCBulkRootStaticVar, Count, AppDomainID, ClrInstanceID, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCBulkRootStaticVar _mcgen_PASTE2(McTemplateU0qxhNR0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCDynamicEvent"
//
#define EventEnabledGCDynamicEvent() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 9)
#define EventEnabledGCDynamicEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 9)

//
// Event write macros for event "GCDynamicEvent"
//
#define EventWriteGCDynamicEvent(Name, DataSize, Data, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCDynamicEvent) \
        ? _mcgen_TEMPLATE_FOR_GCDynamicEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID) : 0
#define EventWriteGCDynamicEvent_AssumeEnabled(Name, DataSize, Data, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDynamicEvent(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID)
#define EventWriteGCDynamicEvent_ForContext(pContext, Name, DataSize, Data, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCDynamicEvent) \
        ? _mcgen_TEMPLATE_FOR_GCDynamicEvent(&(pContext)->Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID) : 0
#define EventWriteGCDynamicEvent_ForContextAssumeEnabled(pContext, Name, DataSize, Data, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCDynamicEvent(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCDynamicEvent, Name, DataSize, Data, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCDynamicEvent _mcgen_PASTE2(McTemplateU0zqbr1h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadCreate"
//
#define EventEnabledWorkerThreadCreate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledWorkerThreadCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadCreate"
//
#define EventWriteWorkerThreadCreate(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadCreate_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads)
#define EventWriteWorkerThreadCreate_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&(pContext)->Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadCreate_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadCreate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadCreate, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadCreate _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadTerminate"
//
#define EventEnabledWorkerThreadTerminate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledWorkerThreadTerminate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadTerminate"
//
#define EventWriteWorkerThreadTerminate(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadTerminate_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads)
#define EventWriteWorkerThreadTerminate_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&(pContext)->Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadTerminate_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadTerminate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadTerminate, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadTerminate _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadRetire"
//
#define EventEnabledWorkerThreadRetire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledWorkerThreadRetire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadRetire"
//
#define EventWriteWorkerThreadRetire(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadRetire_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads)
#define EventWriteWorkerThreadRetire_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&(pContext)->Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadRetire_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadRetire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadRetire, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadRetire _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WorkerThreadUnretire"
//
#define EventEnabledWorkerThreadUnretire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledWorkerThreadUnretire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "WorkerThreadUnretire"
//
#define EventWriteWorkerThreadUnretire(WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED(WorkerThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadUnretire_AssumeEnabled(WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads)
#define EventWriteWorkerThreadUnretire_ForContext(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WorkerThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&(pContext)->Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads) : 0
#define EventWriteWorkerThreadUnretire_ForContextAssumeEnabled(pContext, WorkerThreadCount, RetiredWorkerThreads) \
        _mcgen_TEMPLATE_FOR_WorkerThreadUnretire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &WorkerThreadUnretire, WorkerThreadCount, RetiredWorkerThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WorkerThreadUnretire _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadCreate"
//
#define EventEnabledIOThreadCreate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadCreate"
//
#define EventWriteIOThreadCreate(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadCreate_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads)
#define EventWriteIOThreadCreate_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadCreate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate(&(pContext)->Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadCreate_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadCreate, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadCreate _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadCreate_V1"
//
#define EventEnabledIOThreadCreate_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadCreate_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadCreate_V1"
//
#define EventWriteIOThreadCreate_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadCreate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadCreate_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define EventWriteIOThreadCreate_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadCreate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&(pContext)->Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadCreate_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadCreate_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadCreate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadCreate_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadTerminate"
//
#define EventEnabledIOThreadTerminate() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadTerminate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadTerminate"
//
#define EventWriteIOThreadTerminate(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadTerminate_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads)
#define EventWriteIOThreadTerminate_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadTerminate) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate(&(pContext)->Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadTerminate_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadTerminate, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadTerminate _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadTerminate_V1"
//
#define EventEnabledIOThreadTerminate_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadTerminate_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadTerminate_V1"
//
#define EventWriteIOThreadTerminate_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadTerminate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadTerminate_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define EventWriteIOThreadTerminate_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadTerminate_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&(pContext)->Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadTerminate_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadTerminate_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadTerminate_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadRetire"
//
#define EventEnabledIOThreadRetire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadRetire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadRetire"
//
#define EventWriteIOThreadRetire(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadRetire_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads)
#define EventWriteIOThreadRetire_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadRetire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire(&(pContext)->Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadRetire_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadRetire, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadRetire _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadRetire_V1"
//
#define EventEnabledIOThreadRetire_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadRetire_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadRetire_V1"
//
#define EventWriteIOThreadRetire_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadRetire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadRetire_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define EventWriteIOThreadRetire_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadRetire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&(pContext)->Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadRetire_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadRetire_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadRetire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadRetire_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadUnretire"
//
#define EventEnabledIOThreadUnretire() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadUnretire_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadUnretire"
//
#define EventWriteIOThreadUnretire(IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED(IOThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadUnretire_AssumeEnabled(IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads)
#define EventWriteIOThreadUnretire_ForContext(pContext, IOThreadCount, RetiredIOThreads) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadUnretire) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire(&(pContext)->Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads) : 0
#define EventWriteIOThreadUnretire_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadUnretire, IOThreadCount, RetiredIOThreads)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadUnretire _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IOThreadUnretire_V1"
//
#define EventEnabledIOThreadUnretire_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledIOThreadUnretire_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "IOThreadUnretire_V1"
//
#define EventWriteIOThreadUnretire_V1(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IOThreadUnretire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadUnretire_V1_AssumeEnabled(IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)
#define EventWriteIOThreadUnretire_V1_ForContext(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IOThreadUnretire_V1) \
        ? _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&(pContext)->Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID) : 0
#define EventWriteIOThreadUnretire_V1_ForContextAssumeEnabled(pContext, IOThreadCount, RetiredIOThreads, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IOThreadUnretire_V1, IOThreadCount, RetiredIOThreads, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IOThreadUnretire_V1 _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadpoolSuspensionSuspendThread"
//
#define EventEnabledThreadpoolSuspensionSuspendThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadpoolSuspensionSuspendThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadpoolSuspensionSuspendThread"
//
#define EventWriteThreadpoolSuspensionSuspendThread(ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED(ThreadpoolSuspensionSuspendThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization) : 0
#define EventWriteThreadpoolSuspensionSuspendThread_AssumeEnabled(ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization)
#define EventWriteThreadpoolSuspensionSuspendThread_ForContext(pContext, ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadpoolSuspensionSuspendThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&(pContext)->Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization) : 0
#define EventWriteThreadpoolSuspensionSuspendThread_ForContextAssumeEnabled(pContext, ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadpoolSuspensionSuspendThread, ClrThreadID, CpuUtilization)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionSuspendThread _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadpoolSuspensionResumeThread"
//
#define EventEnabledThreadpoolSuspensionResumeThread() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadpoolSuspensionResumeThread_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadpoolSuspensionResumeThread"
//
#define EventWriteThreadpoolSuspensionResumeThread(ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED(ThreadpoolSuspensionResumeThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization) : 0
#define EventWriteThreadpoolSuspensionResumeThread_AssumeEnabled(ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization)
#define EventWriteThreadpoolSuspensionResumeThread_ForContext(pContext, ClrThreadID, CpuUtilization) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadpoolSuspensionResumeThread) \
        ? _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&(pContext)->Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization) : 0
#define EventWriteThreadpoolSuspensionResumeThread_ForContextAssumeEnabled(pContext, ClrThreadID, CpuUtilization) \
        _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadpoolSuspensionResumeThread, ClrThreadID, CpuUtilization)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadpoolSuspensionResumeThread _mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadStart"
//
#define EventEnabledThreadPoolWorkerThreadStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadStart"
//
#define EventWriteThreadPoolWorkerThreadStart(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadStart_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadStart_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&(pContext)->Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadStart_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStart _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadStop"
//
#define EventEnabledThreadPoolWorkerThreadStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadStop"
//
#define EventWriteThreadPoolWorkerThreadStop(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadStop_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadStop_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&(pContext)->Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadStop_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadStop _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadRetirementStart"
//
#define EventEnabledThreadPoolWorkerThreadRetirementStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadRetirementStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadRetirementStart"
//
#define EventWriteThreadPoolWorkerThreadRetirementStart(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadRetirementStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadRetirementStart_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadRetirementStart_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadRetirementStart) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&(pContext)->Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadRetirementStart_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadRetirementStart, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStart _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadRetirementStop"
//
#define EventEnabledThreadPoolWorkerThreadRetirementStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadRetirementStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadRetirementStop"
//
#define EventWriteThreadPoolWorkerThreadRetirementStop(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadRetirementStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadRetirementStop_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadRetirementStop_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadRetirementStop) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&(pContext)->Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadRetirementStop_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadRetirementStop, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadRetirementStop _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentSample"
//
#define EventEnabledThreadPoolWorkerThreadAdjustmentSample() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadAdjustmentSample_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentSample"
//
#define EventWriteThreadPoolWorkerThreadAdjustmentSample(Throughput, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentSample) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentSample_AssumeEnabled(Throughput, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadAdjustmentSample_ForContext(pContext, Throughput, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentSample) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentSample_ForContextAssumeEnabled(pContext, Throughput, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentSample, Throughput, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentSample _mcgen_PASTE2(McTemplateU0gh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentAdjustment"
//
#define EventEnabledThreadPoolWorkerThreadAdjustmentAdjustment() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadAdjustmentAdjustment_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentAdjustment"
//
#define EventWriteThreadPoolWorkerThreadAdjustmentAdjustment(AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentAdjustment) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentAdjustment_AssumeEnabled(AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadAdjustmentAdjustment_ForContext(pContext, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentAdjustment) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentAdjustment_ForContextAssumeEnabled(pContext, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentAdjustment, AverageThroughput, NewWorkerThreadCount, Reason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentAdjustment _mcgen_PASTE2(McTemplateU0gqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadAdjustmentStats"
//
#define EventEnabledThreadPoolWorkerThreadAdjustmentStats() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventEnabledThreadPoolWorkerThreadAdjustmentStats_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolWorkerThreadAdjustmentStats"
//
#define EventWriteThreadPoolWorkerThreadAdjustmentStats(Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadAdjustmentStats) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentStats_AssumeEnabled(Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadAdjustmentStats_ForContext(pContext, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadAdjustmentStats) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadAdjustmentStats_ForContextAssumeEnabled(pContext, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadAdjustmentStats, Duration, Throughput, ThreadWave, ThroughputWave, ThroughputErrorEstimate, AverageThroughputErrorEstimate, ThroughputRatio, Confidence, NewControlSetting, NewThreadWaveMagnitude, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadAdjustmentStats _mcgen_PASTE2(McTemplateU0ggggggggghh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkerThreadWait"
//
#define EventEnabledThreadPoolWorkerThreadWait() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 10)
#define EventEnabledThreadPoolWorkerThreadWait_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 10)

//
// Event write macros for event "ThreadPoolWorkerThreadWait"
//
#define EventWriteThreadPoolWorkerThreadWait(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkerThreadWait) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadWait_AssumeEnabled(ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)
#define EventWriteThreadPoolWorkerThreadWait_ForContext(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkerThreadWait) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&(pContext)->Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkerThreadWait_ForContextAssumeEnabled(pContext, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkerThreadWait, ActiveWorkerThreadCount, RetiredWorkerThreadCount, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkerThreadWait _mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolWorkingThreadCount"
//
#define EventEnabledThreadPoolWorkingThreadCount() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventEnabledThreadPoolWorkingThreadCount_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolWorkingThreadCount"
//
#define EventWriteThreadPoolWorkingThreadCount(Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolWorkingThreadCount) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkingThreadCount_AssumeEnabled(Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID)
#define EventWriteThreadPoolWorkingThreadCount_ForContext(pContext, Count, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolWorkingThreadCount) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&(pContext)->Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID) : 0
#define EventWriteThreadPoolWorkingThreadCount_ForContextAssumeEnabled(pContext, Count, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolWorkingThreadCount, Count, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolWorkingThreadCount _mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolEnqueue"
//
#define EventEnabledThreadPoolEnqueue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventEnabledThreadPoolEnqueue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolEnqueue"
//
#define EventWriteThreadPoolEnqueue(WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID) : 0
#define EventWriteThreadPoolEnqueue_AssumeEnabled(WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID)
#define EventWriteThreadPoolEnqueue_ForContext(pContext, WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&(pContext)->Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID) : 0
#define EventWriteThreadPoolEnqueue_ForContextAssumeEnabled(pContext, WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolEnqueue, WorkID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolEnqueue _mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolDequeue"
//
#define EventEnabledThreadPoolDequeue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventEnabledThreadPoolDequeue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolDequeue"
//
#define EventWriteThreadPoolDequeue(WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolDequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolDequeue, WorkID, ClrInstanceID) : 0
#define EventWriteThreadPoolDequeue_AssumeEnabled(WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolDequeue, WorkID, ClrInstanceID)
#define EventWriteThreadPoolDequeue_ForContext(pContext, WorkID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolDequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&(pContext)->Context, &ThreadPoolDequeue, WorkID, ClrInstanceID) : 0
#define EventWriteThreadPoolDequeue_ForContextAssumeEnabled(pContext, WorkID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolDequeue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolDequeue, WorkID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolDequeue _mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIOEnqueue"
//
#define EventEnabledThreadPoolIOEnqueue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventEnabledThreadPoolIOEnqueue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolIOEnqueue"
//
#define EventWriteThreadPoolIOEnqueue(NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIOEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) : 0
#define EventWriteThreadPoolIOEnqueue_AssumeEnabled(NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID)
#define EventWriteThreadPoolIOEnqueue_ForContext(pContext, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIOEnqueue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&(pContext)->Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) : 0
#define EventWriteThreadPoolIOEnqueue_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIOEnqueue, NativeOverlapped, Overlapped, MultiDequeues, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIOEnqueue _mcgen_PASTE2(McTemplateU0ppth_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIODequeue"
//
#define EventEnabledThreadPoolIODequeue() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 12)
#define EventEnabledThreadPoolIODequeue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 12)

//
// Event write macros for event "ThreadPoolIODequeue"
//
#define EventWriteThreadPoolIODequeue(NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIODequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define EventWriteThreadPoolIODequeue_AssumeEnabled(NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID)
#define EventWriteThreadPoolIODequeue_ForContext(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIODequeue) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&(pContext)->Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define EventWriteThreadPoolIODequeue_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIODequeue, NativeOverlapped, Overlapped, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIODequeue _mcgen_PASTE2(McTemplateU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadPoolIOPack"
//
#define EventEnabledThreadPoolIOPack() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 11)
#define EventEnabledThreadPoolIOPack_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 11)

//
// Event write macros for event "ThreadPoolIOPack"
//
#define EventWriteThreadPoolIOPack(NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadPoolIOPack) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define EventWriteThreadPoolIOPack_AssumeEnabled(NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID)
#define EventWriteThreadPoolIOPack_ForContext(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadPoolIOPack) \
        ? _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&(pContext)->Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID) : 0
#define EventWriteThreadPoolIOPack_ForContextAssumeEnabled(pContext, NativeOverlapped, Overlapped, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadPoolIOPack(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadPoolIOPack, NativeOverlapped, Overlapped, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadPoolIOPack _mcgen_PASTE2(McTemplateU0pph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadCreating"
//
#define EventEnabledThreadCreating() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 13)
#define EventEnabledThreadCreating_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 13)

//
// Event write macros for event "ThreadCreating"
//
#define EventWriteThreadCreating(ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadCreating) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreating(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreating, ID, ClrInstanceID) : 0
#define EventWriteThreadCreating_AssumeEnabled(ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreating(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreating, ID, ClrInstanceID)
#define EventWriteThreadCreating_ForContext(pContext, ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadCreating) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreating(&(pContext)->Context, &ThreadCreating, ID, ClrInstanceID) : 0
#define EventWriteThreadCreating_ForContextAssumeEnabled(pContext, ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreating(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadCreating, ID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadCreating _mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadRunning"
//
#define EventEnabledThreadRunning() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 13)
#define EventEnabledThreadRunning_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 13)

//
// Event write macros for event "ThreadRunning"
//
#define EventWriteThreadRunning(ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadRunning) \
        ? _mcgen_TEMPLATE_FOR_ThreadRunning(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadRunning, ID, ClrInstanceID) : 0
#define EventWriteThreadRunning_AssumeEnabled(ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadRunning(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadRunning, ID, ClrInstanceID)
#define EventWriteThreadRunning_ForContext(pContext, ID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadRunning) \
        ? _mcgen_TEMPLATE_FOR_ThreadRunning(&(pContext)->Context, &ThreadRunning, ID, ClrInstanceID) : 0
#define EventWriteThreadRunning_ForContextAssumeEnabled(pContext, ID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadRunning(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadRunning, ID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadRunning _mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrown"
//
#define EventEnabledExceptionThrown() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 14)
#define EventEnabledExceptionThrown_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 14)

//
// Event write macros for event "ExceptionThrown"
//
#define EventWriteExceptionThrown() \
        MCGEN_EVENT_ENABLED(ExceptionThrown) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown) : 0
#define EventWriteExceptionThrown_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionThrown(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown)
#define EventWriteExceptionThrown_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrown) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown(&(pContext)->Context, &ExceptionThrown) : 0
#define EventWriteExceptionThrown_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrown)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrown _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrown_V1"
//
#define EventEnabledExceptionThrown_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 15)
#define EventEnabledExceptionThrown_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 15)

//
// Event write macros for event "ExceptionThrown_V1"
//
#define EventWriteExceptionThrown_V1(ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionThrown_V1) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) : 0
#define EventWriteExceptionThrown_V1_AssumeEnabled(ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID)
#define EventWriteExceptionThrown_V1_ForContext(pContext, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrown_V1) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&(pContext)->Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) : 0
#define EventWriteExceptionThrown_V1_ForContextAssumeEnabled(pContext, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionThrown_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrown_V1, ExceptionType, ExceptionMessage, ExceptionEIP, ExceptionHRESULT, ExceptionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrown_V1 _mcgen_PASTE2(McTemplateU0zzpqhh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionCatchStart"
//
#define EventEnabledExceptionCatchStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionCatchStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionCatchStart"
//
#define EventWriteExceptionCatchStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionCatchStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionCatchStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define EventWriteExceptionCatchStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionCatchStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&(pContext)->Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionCatchStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionCatchStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionCatchStart _mcgen_PASTE2(McTemplateU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionCatchStop"
//
#define EventEnabledExceptionCatchStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionCatchStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionCatchStop"
//
#define EventWriteExceptionCatchStop() \
        MCGEN_EVENT_ENABLED(ExceptionCatchStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStop) : 0
#define EventWriteExceptionCatchStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionCatchStop)
#define EventWriteExceptionCatchStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionCatchStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&(pContext)->Context, &ExceptionCatchStop) : 0
#define EventWriteExceptionCatchStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionCatchStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionCatchStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionCatchStop _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFinallyStart"
//
#define EventEnabledExceptionFinallyStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionFinallyStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionFinallyStart"
//
#define EventWriteExceptionFinallyStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionFinallyStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionFinallyStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define EventWriteExceptionFinallyStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFinallyStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&(pContext)->Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionFinallyStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFinallyStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFinallyStart _mcgen_PASTE2(McTemplateU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFinallyStop"
//
#define EventEnabledExceptionFinallyStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionFinallyStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionFinallyStop"
//
#define EventWriteExceptionFinallyStop() \
        MCGEN_EVENT_ENABLED(ExceptionFinallyStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStop) : 0
#define EventWriteExceptionFinallyStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFinallyStop)
#define EventWriteExceptionFinallyStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFinallyStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&(pContext)->Context, &ExceptionFinallyStop) : 0
#define EventWriteExceptionFinallyStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionFinallyStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFinallyStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFinallyStop _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFilterStart"
//
#define EventEnabledExceptionFilterStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionFilterStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionFilterStart"
//
#define EventWriteExceptionFilterStart(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ExceptionFilterStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionFilterStart_AssumeEnabled(EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID)
#define EventWriteExceptionFilterStart_ForContext(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFilterStart) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&(pContext)->Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID) : 0
#define EventWriteExceptionFilterStart_ForContextAssumeEnabled(pContext, EntryEIP, MethodID, MethodName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFilterStart, EntryEIP, MethodID, MethodName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFilterStart _mcgen_PASTE2(McTemplateU0xxzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionFilterStop"
//
#define EventEnabledExceptionFilterStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionFilterStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionFilterStop"
//
#define EventWriteExceptionFilterStop() \
        MCGEN_EVENT_ENABLED(ExceptionFilterStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStop) : 0
#define EventWriteExceptionFilterStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionFilterStop)
#define EventWriteExceptionFilterStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionFilterStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&(pContext)->Context, &ExceptionFilterStop) : 0
#define EventWriteExceptionFilterStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionFilterStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionFilterStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionFilterStop _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ExceptionThrownStop"
//
#define EventEnabledExceptionThrownStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 16)
#define EventEnabledExceptionThrownStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 16)

//
// Event write macros for event "ExceptionThrownStop"
//
#define EventWriteExceptionThrownStop() \
        MCGEN_EVENT_ENABLED(ExceptionThrownStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrownStop) : 0
#define EventWriteExceptionThrownStop_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ExceptionThrownStop)
#define EventWriteExceptionThrownStop_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ExceptionThrownStop) \
        ? _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&(pContext)->Context, &ExceptionThrownStop) : 0
#define EventWriteExceptionThrownStop_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_ExceptionThrownStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ExceptionThrownStop)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ExceptionThrownStop _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "Contention"
//
#define EventEnabledContention() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 14)
#define EventEnabledContention_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 14)

//
// Event write macros for event "Contention"
//
#define EventWriteContention() \
        MCGEN_EVENT_ENABLED(Contention) \
        ? _mcgen_TEMPLATE_FOR_Contention(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Contention) : 0
#define EventWriteContention_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_Contention(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &Contention)
#define EventWriteContention_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, Contention) \
        ? _mcgen_TEMPLATE_FOR_Contention(&(pContext)->Context, &Contention) : 0
#define EventWriteContention_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_Contention(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &Contention)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_Contention _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStart_V1"
//
#define EventEnabledContentionStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 17)
#define EventEnabledContentionStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 17)

//
// Event write macros for event "ContentionStart_V1"
//
#define EventWriteContentionStart_V1(ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ContentionStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID) : 0
#define EventWriteContentionStart_V1_AssumeEnabled(ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID)
#define EventWriteContentionStart_V1_ForContext(pContext, ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ContentionStart_V1(&(pContext)->Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID) : 0
#define EventWriteContentionStart_V1_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStart_V1, ContentionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStart_V1 _mcgen_PASTE2(McTemplateU0uh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ContentionStop"
//
#define EventEnabledContentionStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 17)
#define EventEnabledContentionStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 17)

//
// Event write macros for event "ContentionStop"
//
#define EventWriteContentionStop(ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ContentionStop) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop, ContentionFlags, ClrInstanceID) : 0
#define EventWriteContentionStop_AssumeEnabled(ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ContentionStop, ContentionFlags, ClrInstanceID)
#define EventWriteContentionStop_ForContext(pContext, ContentionFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ContentionStop) \
        ? _mcgen_TEMPLATE_FOR_ContentionStop(&(pContext)->Context, &ContentionStop, ContentionFlags, ClrInstanceID) : 0
#define EventWriteContentionStop_ForContextAssumeEnabled(pContext, ContentionFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ContentionStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ContentionStop, ContentionFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ContentionStop _mcgen_PASTE2(McTemplateU0uh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "CLRStackWalk"
//
#define EventEnabledCLRStackWalk() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 18)
#define EventEnabledCLRStackWalk_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 18)

//
// Event write macros for event "CLRStackWalk"
//
#define EventWriteCLRStackWalk(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalk) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalk(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define EventWriteCLRStackWalk_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalk(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define EventWriteCLRStackWalk_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalk) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalk(&(pContext)->Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define EventWriteCLRStackWalk_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalk(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &CLRStackWalk, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalk _mcgen_PASTE2(McTemplateU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainMemAllocated"
//
#define EventEnabledAppDomainMemAllocated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventEnabledAppDomainMemAllocated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "AppDomainMemAllocated"
//
#define EventWriteAppDomainMemAllocated(AppDomainID, Allocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainMemAllocated) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID) : 0
#define EventWriteAppDomainMemAllocated_AssumeEnabled(AppDomainID, Allocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID)
#define EventWriteAppDomainMemAllocated_ForContext(pContext, AppDomainID, Allocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainMemAllocated) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&(pContext)->Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID) : 0
#define EventWriteAppDomainMemAllocated_ForContextAssumeEnabled(pContext, AppDomainID, Allocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemAllocated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainMemAllocated, AppDomainID, Allocated, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainMemAllocated _mcgen_PASTE2(McTemplateU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainMemSurvived"
//
#define EventEnabledAppDomainMemSurvived() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 19)
#define EventEnabledAppDomainMemSurvived_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 19)

//
// Event write macros for event "AppDomainMemSurvived"
//
#define EventWriteAppDomainMemSurvived(AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainMemSurvived) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) : 0
#define EventWriteAppDomainMemSurvived_AssumeEnabled(AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID)
#define EventWriteAppDomainMemSurvived_ForContext(pContext, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainMemSurvived) \
        ? _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&(pContext)->Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) : 0
#define EventWriteAppDomainMemSurvived_ForContextAssumeEnabled(pContext, AppDomainID, Survived, ProcessSurvived, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainMemSurvived(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainMemSurvived, AppDomainID, Survived, ProcessSurvived, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainMemSurvived _mcgen_PASTE2(McTemplateU0xxxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadCreated"
//
#define EventEnabledThreadCreated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 20)
#define EventEnabledThreadCreated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 20)

//
// Event write macros for event "ThreadCreated"
//
#define EventWriteThreadCreated(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadCreated) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define EventWriteThreadCreated_AssumeEnabled(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)
#define EventWriteThreadCreated_ForContext(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadCreated) \
        ? _mcgen_TEMPLATE_FOR_ThreadCreated(&(pContext)->Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define EventWriteThreadCreated_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadCreated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadCreated, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadCreated _mcgen_PASTE2(McTemplateU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadTerminated"
//
#define EventEnabledThreadTerminated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 20)
#define EventEnabledThreadTerminated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 20)

//
// Event write macros for event "ThreadTerminated"
//
#define EventWriteThreadTerminated(ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadTerminated) \
        ? _mcgen_TEMPLATE_FOR_ThreadTerminated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define EventWriteThreadTerminated_AssumeEnabled(ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadTerminated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID)
#define EventWriteThreadTerminated_ForContext(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadTerminated) \
        ? _mcgen_TEMPLATE_FOR_ThreadTerminated(&(pContext)->Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define EventWriteThreadTerminated_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadTerminated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadTerminated, ManagedThreadID, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadTerminated _mcgen_PASTE2(McTemplateU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadDomainEnter"
//
#define EventEnabledThreadDomainEnter() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 20)
#define EventEnabledThreadDomainEnter_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 20)

//
// Event write macros for event "ThreadDomainEnter"
//
#define EventWriteThreadDomainEnter(ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadDomainEnter) \
        ? _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define EventWriteThreadDomainEnter_AssumeEnabled(ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID)
#define EventWriteThreadDomainEnter_ForContext(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadDomainEnter) \
        ? _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&(pContext)->Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID) : 0
#define EventWriteThreadDomainEnter_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDomainEnter(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ThreadDomainEnter, ManagedThreadID, AppDomainID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadDomainEnter _mcgen_PASTE2(McTemplateU0xxh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ILStubGenerated"
//
#define EventEnabledILStubGenerated() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 21)
#define EventEnabledILStubGenerated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 21)

//
// Event write macros for event "ILStubGenerated"
//
#define EventWriteILStubGenerated(ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        MCGEN_EVENT_ENABLED(ILStubGenerated) \
        ? _mcgen_TEMPLATE_FOR_ILStubGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) : 0
#define EventWriteILStubGenerated_AssumeEnabled(ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        _mcgen_TEMPLATE_FOR_ILStubGenerated(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode)
#define EventWriteILStubGenerated_ForContext(pContext, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ILStubGenerated) \
        ? _mcgen_TEMPLATE_FOR_ILStubGenerated(&(pContext)->Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) : 0
#define EventWriteILStubGenerated_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode) \
        _mcgen_TEMPLATE_FOR_ILStubGenerated(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ILStubGenerated, ClrInstanceID, ModuleID, StubMethodID, StubFlags, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature, NativeMethodSignature, StubMethodSignature, StubMethodILCode)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ILStubGenerated _mcgen_PASTE2(McTemplateU0hxxqqzzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ILStubCacheHit"
//
#define EventEnabledILStubCacheHit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 21)
#define EventEnabledILStubCacheHit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 21)

//
// Event write macros for event "ILStubCacheHit"
//
#define EventWriteILStubCacheHit(ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        MCGEN_EVENT_ENABLED(ILStubCacheHit) \
        ? _mcgen_TEMPLATE_FOR_ILStubCacheHit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) : 0
#define EventWriteILStubCacheHit_AssumeEnabled(ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        _mcgen_TEMPLATE_FOR_ILStubCacheHit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature)
#define EventWriteILStubCacheHit_ForContext(pContext, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ILStubCacheHit) \
        ? _mcgen_TEMPLATE_FOR_ILStubCacheHit(&(pContext)->Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) : 0
#define EventWriteILStubCacheHit_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature) \
        _mcgen_TEMPLATE_FOR_ILStubCacheHit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ILStubCacheHit, ClrInstanceID, ModuleID, StubMethodID, ManagedInteropMethodToken, ManagedInteropMethodNamespace, ManagedInteropMethodName, ManagedInteropMethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ILStubCacheHit _mcgen_PASTE2(McTemplateU0hxxqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartCompleteV2"
//
#define EventEnabledDCStartCompleteV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledDCStartCompleteV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "DCStartCompleteV2"
//
#define EventWriteDCStartCompleteV2() \
        MCGEN_EVENT_ENABLED(DCStartCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCStartCompleteV2) : 0
#define EventWriteDCStartCompleteV2_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCStartCompleteV2)
#define EventWriteDCStartCompleteV2_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&(pContext)->Context, &DCStartCompleteV2) : 0
#define EventWriteDCStartCompleteV2_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartCompleteV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DCStartCompleteV2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartCompleteV2 _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndCompleteV2"
//
#define EventEnabledDCEndCompleteV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledDCEndCompleteV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "DCEndCompleteV2"
//
#define EventWriteDCEndCompleteV2() \
        MCGEN_EVENT_ENABLED(DCEndCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCEndCompleteV2) : 0
#define EventWriteDCEndCompleteV2_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DCEndCompleteV2)
#define EventWriteDCEndCompleteV2_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndCompleteV2) \
        ? _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&(pContext)->Context, &DCEndCompleteV2) : 0
#define EventWriteDCEndCompleteV2_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndCompleteV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DCEndCompleteV2)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndCompleteV2 _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartV2"
//
#define EventEnabledMethodDCStartV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodDCStartV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodDCStartV2"
//
#define EventWriteMethodDCStartV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCStartV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodDCStartV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartV2(&(pContext)->Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCStartV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStartV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCStartV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartV2 _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndV2"
//
#define EventEnabledMethodDCEndV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodDCEndV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodDCEndV2"
//
#define EventWriteMethodDCEndV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCEndV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodDCEndV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndV2(&(pContext)->Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCEndV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEndV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCEndV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndV2 _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerboseV2"
//
#define EventEnabledMethodDCStartVerboseV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodDCStartVerboseV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodDCStartVerboseV2"
//
#define EventWriteMethodDCStartVerboseV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCStartVerboseV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodDCStartVerboseV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&(pContext)->Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCStartVerboseV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCStartVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerboseV2 _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerboseV2"
//
#define EventEnabledMethodDCEndVerboseV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodDCEndVerboseV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodDCEndVerboseV2"
//
#define EventWriteMethodDCEndVerboseV2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCEndVerboseV2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodDCEndVerboseV2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerboseV2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&(pContext)->Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCEndVerboseV2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodDCEndVerboseV2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerboseV2 _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad"
//
#define EventEnabledMethodLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoad"
//
#define EventWriteMethodLoad(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodLoad) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodLoad_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodLoad_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad(&(pContext)->Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodLoad_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad_V1"
//
#define EventEnabledMethodLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoad_V1"
//
#define EventWriteMethodLoad_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodLoad_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define EventWriteMethodLoad_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V1(&(pContext)->Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodLoad_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad_V1 _mcgen_PASTE2(McTemplateU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoad_V2"
//
#define EventEnabledMethodLoad_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoad_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoad_V2"
//
#define EventWriteMethodLoad_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodLoad_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define EventWriteMethodLoad_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoad_V2(&(pContext)->Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodLoad_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoad_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoad_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoad_V2 _mcgen_PASTE2(McTemplateU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload"
//
#define EventEnabledMethodUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnload"
//
#define EventWriteMethodUnload(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodUnload) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodUnload_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodUnload_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload(&(pContext)->Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodUnload_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload_V1"
//
#define EventEnabledMethodUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnload_V1"
//
#define EventWriteMethodUnload_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodUnload_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define EventWriteMethodUnload_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V1(&(pContext)->Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodUnload_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload_V1 _mcgen_PASTE2(McTemplateU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnload_V2"
//
#define EventEnabledMethodUnload_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnload_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnload_V2"
//
#define EventWriteMethodUnload_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodUnload_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define EventWriteMethodUnload_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnload_V2(&(pContext)->Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodUnload_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnload_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnload_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnload_V2 _mcgen_PASTE2(McTemplateU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose"
//
#define EventEnabledMethodLoadVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoadVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoadVerbose"
//
#define EventWriteMethodLoadVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodLoadVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodLoadVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&(pContext)->Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodLoadVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose_V1"
//
#define EventEnabledMethodLoadVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoadVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoadVerbose_V1"
//
#define EventWriteMethodLoadVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodLoadVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define EventWriteMethodLoadVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&(pContext)->Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodLoadVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V1 _mcgen_PASTE2(McTemplateU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodLoadVerbose_V2"
//
#define EventEnabledMethodLoadVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodLoadVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodLoadVerbose_V2"
//
#define EventWriteMethodLoadVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodLoadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodLoadVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define EventWriteMethodLoadVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodLoadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&(pContext)->Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodLoadVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodLoadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodLoadVerbose_V2 _mcgen_PASTE2(McTemplateU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose"
//
#define EventEnabledMethodUnloadVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnloadVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnloadVerbose"
//
#define EventWriteMethodUnloadVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodUnloadVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodUnloadVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&(pContext)->Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodUnloadVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose_V1"
//
#define EventEnabledMethodUnloadVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnloadVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnloadVerbose_V1"
//
#define EventWriteMethodUnloadVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodUnloadVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define EventWriteMethodUnloadVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&(pContext)->Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodUnloadVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V1 _mcgen_PASTE2(McTemplateU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodUnloadVerbose_V2"
//
#define EventEnabledMethodUnloadVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 22)
#define EventEnabledMethodUnloadVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 22)

//
// Event write macros for event "MethodUnloadVerbose_V2"
//
#define EventWriteMethodUnloadVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodUnloadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodUnloadVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define EventWriteMethodUnloadVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodUnloadVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&(pContext)->Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodUnloadVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodUnloadVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodUnloadVerbose_V2 _mcgen_PASTE2(McTemplateU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJittingStarted"
//
#define EventEnabledMethodJittingStarted() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 23)
#define EventEnabledMethodJittingStarted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 23)

//
// Event write macros for event "MethodJittingStarted"
//
#define EventWriteMethodJittingStarted(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodJittingStarted) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodJittingStarted_AssumeEnabled(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodJittingStarted_ForContext(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJittingStarted) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted(&(pContext)->Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodJittingStarted_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJittingStarted, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJittingStarted _mcgen_PASTE2(McTemplateU0xxqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJittingStarted_V1"
//
#define EventEnabledMethodJittingStarted_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 23)
#define EventEnabledMethodJittingStarted_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 23)

//
// Event write macros for event "MethodJittingStarted_V1"
//
#define EventWriteMethodJittingStarted_V1(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJittingStarted_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodJittingStarted_V1_AssumeEnabled(MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define EventWriteMethodJittingStarted_V1_ForContext(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJittingStarted_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&(pContext)->Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodJittingStarted_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJittingStarted_V1, MethodID, ModuleID, MethodToken, MethodILSize, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJittingStarted_V1 _mcgen_PASTE2(McTemplateU0xxqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitInliningSucceeded"
//
#define EventEnabledMethodJitInliningSucceeded() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventEnabledMethodJitInliningSucceeded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodJitInliningSucceeded"
//
#define EventWriteMethodJitInliningSucceeded(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitInliningSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) : 0
#define EventWriteMethodJitInliningSucceeded_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID)
#define EventWriteMethodJitInliningSucceeded_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitInliningSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&(pContext)->Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) : 0
#define EventWriteMethodJitInliningSucceeded_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitInliningSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitInliningSucceeded _mcgen_PASTE2(McTemplateU0zzzzzzzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitInliningFailed"
//
#define EventEnabledMethodJitInliningFailed() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventEnabledMethodJitInliningFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodJitInliningFailed"
//
#define EventWriteMethodJitInliningFailed(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitInliningFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define EventWriteMethodJitInliningFailed_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)
#define EventWriteMethodJitInliningFailed_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitInliningFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&(pContext)->Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) : 0
#define EventWriteMethodJitInliningFailed_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitInliningFailed(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitInliningFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, InlinerNamespace, InlinerName, InlinerNameSignature, InlineeNamespace, InlineeName, InlineeNameSignature, FailAlways, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitInliningFailed _mcgen_PASTE2(McTemplateU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitTailCallSucceeded"
//
#define EventEnabledMethodJitTailCallSucceeded() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventEnabledMethodJitTailCallSucceeded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodJitTailCallSucceeded"
//
#define EventWriteMethodJitTailCallSucceeded(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitTailCallSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) : 0
#define EventWriteMethodJitTailCallSucceeded_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID)
#define EventWriteMethodJitTailCallSucceeded_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitTailCallSucceeded) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&(pContext)->Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) : 0
#define EventWriteMethodJitTailCallSucceeded_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitTailCallSucceeded, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, TailCallType, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitTailCallSucceeded _mcgen_PASTE2(McTemplateU0zzzzzzzzztqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodJitTailCallFailed"
//
#define EventEnabledMethodJitTailCallFailed() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 24)
#define EventEnabledMethodJitTailCallFailed_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 24)

//
// Event write macros for event "MethodJitTailCallFailed"
//
#define EventWriteMethodJitTailCallFailed(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodJitTailCallFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define EventWriteMethodJitTailCallFailed_AssumeEnabled(MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)
#define EventWriteMethodJitTailCallFailed_ForContext(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodJitTailCallFailed) \
        ? _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&(pContext)->Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) : 0
#define EventWriteMethodJitTailCallFailed_ForContextAssumeEnabled(pContext, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodJitTailCallFailed, MethodBeingCompiledNamespace, MethodBeingCompiledName, MethodBeingCompiledNameSignature, CallerNamespace, CallerName, CallerNameSignature, CalleeNamespace, CalleeName, CalleeNameSignature, TailPrefix, FailReason, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodJitTailCallFailed _mcgen_PASTE2(McTemplateU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodILToNativeMap"
//
#define EventEnabledMethodILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 25)
#define EventEnabledMethodILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 25)

//
// Event write macros for event "MethodILToNativeMap"
//
#define EventWriteMethodILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define EventWriteMethodILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&(pContext)->Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &MethodILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodILToNativeMap _mcgen_PASTE2(McTemplateU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStartV2"
//
#define EventEnabledModuleDCStartV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledModuleDCStartV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "ModuleDCStartV2"
//
#define EventWriteModuleDCStartV2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCStartV2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleDCStartV2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStartV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&(pContext)->Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCStartV2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStartV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleDCStartV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStartV2 _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEndV2"
//
#define EventEnabledModuleDCEndV2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledModuleDCEndV2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "ModuleDCEndV2"
//
#define EventWriteModuleDCEndV2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCEndV2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleDCEndV2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEndV2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&(pContext)->Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCEndV2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEndV2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleDCEndV2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEndV2 _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleLoad"
//
#define EventEnabledDomainModuleLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledDomainModuleLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "DomainModuleLoad"
//
#define EventWriteDomainModuleLoad(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleLoad_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteDomainModuleLoad_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad(&(pContext)->Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleLoad_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DomainModuleLoad, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleLoad _mcgen_PASTE2(McTemplateU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleLoad_V1"
//
#define EventEnabledDomainModuleLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledDomainModuleLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "DomainModuleLoad_V1"
//
#define EventWriteDomainModuleLoad_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleLoad_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteDomainModuleLoad_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&(pContext)->Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleLoad_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DomainModuleLoad_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleLoad_V1 _mcgen_PASTE2(McTemplateU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad"
//
#define EventEnabledModuleLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledModuleLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "ModuleLoad"
//
#define EventWriteModuleLoad(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleLoad_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleLoad_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad(&(pContext)->Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleLoad_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad_V1"
//
#define EventEnabledModuleLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventEnabledModuleLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "ModuleLoad_V1"
//
#define EventWriteModuleLoad_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleLoad_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteModuleLoad_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&(pContext)->Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleLoad_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad_V1 _mcgen_PASTE2(McTemplateU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleLoad_V2"
//
#define EventEnabledModuleLoad_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventEnabledModuleLoad_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "ModuleLoad_V2"
//
#define EventWriteModuleLoad_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleLoad_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define EventWriteModuleLoad_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleLoad_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&(pContext)->Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleLoad_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleLoad_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleLoad_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleLoad_V2 _mcgen_PASTE2(McTemplateU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload"
//
#define EventEnabledModuleUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledModuleUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "ModuleUnload"
//
#define EventWriteModuleUnload(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleUnload) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleUnload_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleUnload_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload(&(pContext)->Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleUnload_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload_V1"
//
#define EventEnabledModuleUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventEnabledModuleUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "ModuleUnload_V1"
//
#define EventWriteModuleUnload_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleUnload_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteModuleUnload_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&(pContext)->Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleUnload_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload_V1 _mcgen_PASTE2(McTemplateU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleUnload_V2"
//
#define EventEnabledModuleUnload_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 27)
#define EventEnabledModuleUnload_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 27)

//
// Event write macros for event "ModuleUnload_V2"
//
#define EventWriteModuleUnload_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleUnload_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define EventWriteModuleUnload_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleUnload_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&(pContext)->Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleUnload_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleUnload_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleUnload_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleUnload_V2 _mcgen_PASTE2(McTemplateU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoad"
//
#define EventEnabledAssemblyLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAssemblyLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AssemblyLoad"
//
#define EventWriteAssemblyLoad(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyLoad) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyLoad_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define EventWriteAssemblyLoad_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoad) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad(&(pContext)->Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyLoad_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoad, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoad _mcgen_PASTE2(McTemplateU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyLoad_V1"
//
#define EventEnabledAssemblyLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAssemblyLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AssemblyLoad_V1"
//
#define EventWriteAssemblyLoad_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyLoad_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteAssemblyLoad_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&(pContext)->Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyLoad_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyLoad_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyLoad_V1 _mcgen_PASTE2(McTemplateU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyUnload"
//
#define EventEnabledAssemblyUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAssemblyUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AssemblyUnload"
//
#define EventWriteAssemblyUnload(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyUnload) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyUnload_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define EventWriteAssemblyUnload_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyUnload) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload(&(pContext)->Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyUnload_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyUnload, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyUnload _mcgen_PASTE2(McTemplateU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyUnload_V1"
//
#define EventEnabledAssemblyUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAssemblyUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AssemblyUnload_V1"
//
#define EventWriteAssemblyUnload_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyUnload_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteAssemblyUnload_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&(pContext)->Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyUnload_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AssemblyUnload_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyUnload_V1 _mcgen_PASTE2(McTemplateU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainLoad"
//
#define EventEnabledAppDomainLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAppDomainLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AppDomainLoad"
//
#define EventWriteAppDomainLoad(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainLoad) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainLoad_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName)
#define EventWriteAppDomainLoad_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainLoad) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad(&(pContext)->Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainLoad_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainLoad, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainLoad _mcgen_PASTE2(McTemplateU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainLoad_V1"
//
#define EventEnabledAppDomainLoad_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAppDomainLoad_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AppDomainLoad_V1"
//
#define EventWriteAppDomainLoad_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainLoad_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define EventWriteAppDomainLoad_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainLoad_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&(pContext)->Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainLoad_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainLoad_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainLoad_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainLoad_V1 _mcgen_PASTE2(McTemplateU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainUnload"
//
#define EventEnabledAppDomainUnload() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAppDomainUnload_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AppDomainUnload"
//
#define EventWriteAppDomainUnload(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainUnload) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainUnload_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName)
#define EventWriteAppDomainUnload_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainUnload) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload(&(pContext)->Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainUnload_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainUnload, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainUnload _mcgen_PASTE2(McTemplateU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainUnload_V1"
//
#define EventEnabledAppDomainUnload_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 26)
#define EventEnabledAppDomainUnload_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 26)

//
// Event write macros for event "AppDomainUnload_V1"
//
#define EventWriteAppDomainUnload_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainUnload_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define EventWriteAppDomainUnload_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainUnload_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&(pContext)->Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainUnload_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainUnload_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AppDomainUnload_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainUnload_V1 _mcgen_PASTE2(McTemplateU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeLoad"
//
#define EventEnabledModuleRangeLoad() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 28)
#define EventEnabledModuleRangeLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 28)

//
// Event write macros for event "ModuleRangeLoad"
//
#define EventWriteModuleRangeLoad(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeLoad_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define EventWriteModuleRangeLoad_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeLoad) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&(pContext)->Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeLoad_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeLoad(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &ModuleRangeLoad, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeLoad _mcgen_PASTE2(McTemplateU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStart"
//
#define EventEnabledStrongNameVerificationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventEnabledStrongNameVerificationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "StrongNameVerificationStart"
//
#define EventWriteStrongNameVerificationStart(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define EventWriteStrongNameVerificationStart_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)
#define EventWriteStrongNameVerificationStart_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&(pContext)->Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define EventWriteStrongNameVerificationStart_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStart, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStart _mcgen_PASTE2(McTemplateU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStart_V1"
//
#define EventEnabledStrongNameVerificationStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventEnabledStrongNameVerificationStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "StrongNameVerificationStart_V1"
//
#define EventWriteStrongNameVerificationStart_V1(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteStrongNameVerificationStart_V1_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteStrongNameVerificationStart_V1_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&(pContext)->Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteStrongNameVerificationStart_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStart_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStart_V1 _mcgen_PASTE2(McTemplateU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStop"
//
#define EventEnabledStrongNameVerificationStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventEnabledStrongNameVerificationStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "StrongNameVerificationStop"
//
#define EventWriteStrongNameVerificationStop(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define EventWriteStrongNameVerificationStop_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)
#define EventWriteStrongNameVerificationStop_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&(pContext)->Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) : 0
#define EventWriteStrongNameVerificationStop_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStop, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStop _mcgen_PASTE2(McTemplateU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "StrongNameVerificationStop_V1"
//
#define EventEnabledStrongNameVerificationStop_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventEnabledStrongNameVerificationStop_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "StrongNameVerificationStop_V1"
//
#define EventWriteStrongNameVerificationStop_V1(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(StrongNameVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteStrongNameVerificationStop_V1_AssumeEnabled(VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteStrongNameVerificationStop_V1_ForContext(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, StrongNameVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&(pContext)->Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteStrongNameVerificationStop_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &StrongNameVerificationStop_V1, VerificationFlags, ErrorCode, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_StrongNameVerificationStop_V1 _mcgen_PASTE2(McTemplateU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStart"
//
#define EventEnabledAuthenticodeVerificationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventEnabledAuthenticodeVerificationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AuthenticodeVerificationStart"
//
#define EventWriteAuthenticodeVerificationStart(VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath) : 0
#define EventWriteAuthenticodeVerificationStart_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath)
#define EventWriteAuthenticodeVerificationStart_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStart) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&(pContext)->Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath) : 0
#define EventWriteAuthenticodeVerificationStart_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStart, VerificationFlags, ErrorCode, ModulePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart _mcgen_PASTE2(McTemplateU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStart_V1"
//
#define EventEnabledAuthenticodeVerificationStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 29)
#define EventEnabledAuthenticodeVerificationStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 29)

//
// Event write macros for event "AuthenticodeVerificationStart_V1"
//
#define EventWriteAuthenticodeVerificationStart_V1(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define EventWriteAuthenticodeVerificationStart_V1_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)
#define EventWriteAuthenticodeVerificationStart_V1_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&(pContext)->Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define EventWriteAuthenticodeVerificationStart_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStart_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStart_V1 _mcgen_PASTE2(McTemplateU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStop"
//
#define EventEnabledAuthenticodeVerificationStop() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventEnabledAuthenticodeVerificationStop_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "AuthenticodeVerificationStop"
//
#define EventWriteAuthenticodeVerificationStop(VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath) : 0
#define EventWriteAuthenticodeVerificationStop_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath)
#define EventWriteAuthenticodeVerificationStop_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStop) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&(pContext)->Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath) : 0
#define EventWriteAuthenticodeVerificationStop_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStop, VerificationFlags, ErrorCode, ModulePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop _mcgen_PASTE2(McTemplateU0qqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AuthenticodeVerificationStop_V1"
//
#define EventEnabledAuthenticodeVerificationStop_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 30)
#define EventEnabledAuthenticodeVerificationStop_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 30)

//
// Event write macros for event "AuthenticodeVerificationStop_V1"
//
#define EventWriteAuthenticodeVerificationStop_V1(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AuthenticodeVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define EventWriteAuthenticodeVerificationStop_V1_AssumeEnabled(VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)
#define EventWriteAuthenticodeVerificationStop_V1_ForContext(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AuthenticodeVerificationStop_V1) \
        ? _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&(pContext)->Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) : 0
#define EventWriteAuthenticodeVerificationStop_V1_ForContextAssumeEnabled(pContext, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &AuthenticodeVerificationStop_V1, VerificationFlags, ErrorCode, ModulePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AuthenticodeVerificationStop_V1 _mcgen_PASTE2(McTemplateU0qqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RuntimeInformationStart"
//
#define EventEnabledRuntimeInformationStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 14)
#define EventEnabledRuntimeInformationStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 14)

//
// Event write macros for event "RuntimeInformationStart"
//
#define EventWriteRuntimeInformationStart(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED(RuntimeInformationStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define EventWriteRuntimeInformationStart_AssumeEnabled(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)
#define EventWriteRuntimeInformationStart_ForContext(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RuntimeInformationStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&(pContext)->Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define EventWriteRuntimeInformationStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &RuntimeInformationStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RuntimeInformationStart _mcgen_PASTE2(McTemplateU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "IncreaseMemoryPressure"
//
#define EventEnabledIncreaseMemoryPressure() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledIncreaseMemoryPressure_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "IncreaseMemoryPressure"
//
#define EventWriteIncreaseMemoryPressure(BytesAllocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(IncreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID) : 0
#define EventWriteIncreaseMemoryPressure_AssumeEnabled(BytesAllocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID)
#define EventWriteIncreaseMemoryPressure_ForContext(pContext, BytesAllocated, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, IncreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&(pContext)->Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID) : 0
#define EventWriteIncreaseMemoryPressure_ForContextAssumeEnabled(pContext, BytesAllocated, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &IncreaseMemoryPressure, BytesAllocated, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_IncreaseMemoryPressure _mcgen_PASTE2(McTemplateU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DecreaseMemoryPressure"
//
#define EventEnabledDecreaseMemoryPressure() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledDecreaseMemoryPressure_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "DecreaseMemoryPressure"
//
#define EventWriteDecreaseMemoryPressure(BytesFreed, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DecreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID) : 0
#define EventWriteDecreaseMemoryPressure_AssumeEnabled(BytesFreed, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID)
#define EventWriteDecreaseMemoryPressure_ForContext(pContext, BytesFreed, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DecreaseMemoryPressure) \
        ? _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&(pContext)->Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID) : 0
#define EventWriteDecreaseMemoryPressure_ForContextAssumeEnabled(pContext, BytesFreed, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DecreaseMemoryPressure, BytesFreed, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DecreaseMemoryPressure _mcgen_PASTE2(McTemplateU0xh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCMarkWithType"
//
#define EventEnabledGCMarkWithType() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCMarkWithType_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCMarkWithType"
//
#define EventWriteGCMarkWithType(HeapNum, ClrInstanceID, Type, Bytes) \
        MCGEN_EVENT_ENABLED(GCMarkWithType) \
        ? _mcgen_TEMPLATE_FOR_GCMarkWithType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes) : 0
#define EventWriteGCMarkWithType_AssumeEnabled(HeapNum, ClrInstanceID, Type, Bytes) \
        _mcgen_TEMPLATE_FOR_GCMarkWithType(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes)
#define EventWriteGCMarkWithType_ForContext(pContext, HeapNum, ClrInstanceID, Type, Bytes) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCMarkWithType) \
        ? _mcgen_TEMPLATE_FOR_GCMarkWithType(&(pContext)->Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes) : 0
#define EventWriteGCMarkWithType_ForContextAssumeEnabled(pContext, HeapNum, ClrInstanceID, Type, Bytes) \
        _mcgen_TEMPLATE_FOR_GCMarkWithType(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCMarkWithType, HeapNum, ClrInstanceID, Type, Bytes)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCMarkWithType _mcgen_PASTE2(McTemplateU0qhqx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCJoin_V2"
//
#define EventEnabledGCJoin_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 1)
#define EventEnabledGCJoin_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 1)

//
// Event write macros for event "GCJoin_V2"
//
#define EventWriteGCJoin_V2(Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        MCGEN_EVENT_ENABLED(GCJoin_V2) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) : 0
#define EventWriteGCJoin_V2_AssumeEnabled(Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID)
#define EventWriteGCJoin_V2_ForContext(pContext, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCJoin_V2) \
        ? _mcgen_TEMPLATE_FOR_GCJoin_V2(&(pContext)->Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) : 0
#define EventWriteGCJoin_V2_ForContextAssumeEnabled(pContext, Heap, JoinTime, JoinType, ClrInstanceID, JoinID) \
        _mcgen_TEMPLATE_FOR_GCJoin_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCJoin_V2, Heap, JoinTime, JoinType, ClrInstanceID, JoinID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCJoin_V2 _mcgen_PASTE2(McTemplateU0qqqhq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCPerHeapHistory_V3"
//
#define EventEnabledGCPerHeapHistory_V3() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCPerHeapHistory_V3_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCPerHeapHistory_V3"
//
#define EventWriteGCPerHeapHistory_V3(ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED(GCPerHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) : 0
#define EventWriteGCPerHeapHistory_V3_AssumeEnabled(ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values)
#define EventWriteGCPerHeapHistory_V3_ForContext(pContext, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCPerHeapHistory_V3) \
        ? _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&(pContext)->Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) : 0
#define EventWriteGCPerHeapHistory_V3_ForContextAssumeEnabled(pContext, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values) \
        _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCPerHeapHistory_V3, ClrInstanceID, FreeListAllocated, FreeListRejected, EndOfSegAllocated, CondemnedAllocated, PinnedAllocated, PinnedAllocatedAdvance, RunningFreeListEfficiency, CondemnReasons0, CondemnReasons1, CompactMechanisms, ExpandMechanisms, HeapIndex, ExtraGen0Commit, Count, Values_Len_, Values)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCPerHeapHistory_V3 _mcgen_PASTE2(McTemplateU0hppppppqqqqqqpqNR14_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCGlobalHeapHistory_V2"
//
#define EventEnabledGCGlobalHeapHistory_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCGlobalHeapHistory_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCGlobalHeapHistory_V2"
//
#define EventWriteGCGlobalHeapHistory_V2(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        MCGEN_EVENT_ENABLED(GCGlobalHeapHistory_V2) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) : 0
#define EventWriteGCGlobalHeapHistory_V2_AssumeEnabled(FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure)
#define EventWriteGCGlobalHeapHistory_V2_ForContext(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCGlobalHeapHistory_V2) \
        ? _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&(pContext)->Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) : 0
#define EventWriteGCGlobalHeapHistory_V2_ForContextAssumeEnabled(pContext, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure) \
        _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCGlobalHeapHistory_V2, FinalYoungestDesired, NumHeaps, CondemnedGeneration, Gen0ReductionCount, Reason, GlobalMechanisms, ClrInstanceID, PauseMode, MemoryPressure)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCGlobalHeapHistory_V2 _mcgen_PASTE2(McTemplateU0xdqqqqhqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "GCLoaded"
//
#define EventEnabledGCLoaded() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 0)
#define EventEnabledGCLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 0)

//
// Event write macros for event "GCLoaded"
//
#define EventWriteGCLoaded(GCName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(GCLoaded) \
        ? _mcgen_TEMPLATE_FOR_GCLoaded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCLoaded, GCName, ClrInstanceID) : 0
#define EventWriteGCLoaded_AssumeEnabled(GCName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCLoaded(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &GCLoaded, GCName, ClrInstanceID)
#define EventWriteGCLoaded_ForContext(pContext, GCName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, GCLoaded) \
        ? _mcgen_TEMPLATE_FOR_GCLoaded(&(pContext)->Context, &GCLoaded, GCName, ClrInstanceID) : 0
#define EventWriteGCLoaded_ForContextAssumeEnabled(pContext, GCName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_GCLoaded(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &GCLoaded, GCName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_GCLoaded _mcgen_PASTE2(McTemplateU0zh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugIPCEventStart"
//
#define EventEnabledDebugIPCEventStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventEnabledDebugIPCEventStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "DebugIPCEventStart"
//
#define EventWriteDebugIPCEventStart() \
        MCGEN_EVENT_ENABLED(DebugIPCEventStart) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventStart) : 0
#define EventWriteDebugIPCEventStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventStart)
#define EventWriteDebugIPCEventStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugIPCEventStart) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&(pContext)->Context, &DebugIPCEventStart) : 0
#define EventWriteDebugIPCEventStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugIPCEventStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugIPCEventStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugIPCEventStart _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugIPCEventEnd"
//
#define EventEnabledDebugIPCEventEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventEnabledDebugIPCEventEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "DebugIPCEventEnd"
//
#define EventWriteDebugIPCEventEnd() \
        MCGEN_EVENT_ENABLED(DebugIPCEventEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventEnd) : 0
#define EventWriteDebugIPCEventEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugIPCEventEnd)
#define EventWriteDebugIPCEventEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugIPCEventEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&(pContext)->Context, &DebugIPCEventEnd) : 0
#define EventWriteDebugIPCEventEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugIPCEventEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugIPCEventEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugIPCEventEnd _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugExceptionProcessingStart"
//
#define EventEnabledDebugExceptionProcessingStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventEnabledDebugExceptionProcessingStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "DebugExceptionProcessingStart"
//
#define EventWriteDebugExceptionProcessingStart() \
        MCGEN_EVENT_ENABLED(DebugExceptionProcessingStart) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingStart) : 0
#define EventWriteDebugExceptionProcessingStart_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingStart)
#define EventWriteDebugExceptionProcessingStart_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugExceptionProcessingStart) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&(pContext)->Context, &DebugExceptionProcessingStart) : 0
#define EventWriteDebugExceptionProcessingStart_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugExceptionProcessingStart)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugExceptionProcessingStart _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DebugExceptionProcessingEnd"
//
#define EventEnabledDebugExceptionProcessingEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeEnableBits, 31)
#define EventEnabledDebugExceptionProcessingEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->EnableBits, 31)

//
// Event write macros for event "DebugExceptionProcessingEnd"
//
#define EventWriteDebugExceptionProcessingEnd() \
        MCGEN_EVENT_ENABLED(DebugExceptionProcessingEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingEnd) : 0
#define EventWriteDebugExceptionProcessingEnd_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_PROVIDER_Context, &DebugExceptionProcessingEnd)
#define EventWriteDebugExceptionProcessingEnd_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DebugExceptionProcessingEnd) \
        ? _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&(pContext)->Context, &DebugExceptionProcessingEnd) : 0
#define EventWriteDebugExceptionProcessingEnd_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntime(pContext)->Context, &DebugExceptionProcessingEnd)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DebugExceptionProcessingEnd _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "Microsoft-Windows-DotNETRuntimeRundown" event count 45
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = a669021c-c450-4609-a035-5af59af4df18
EXTERN_C __declspec(selectany) const GUID MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER = {0xa669021c, 0xc450, 0x4609, {0xa0, 0x35, 0x5a, 0xf5, 0x9a, 0xf4, 0xdf, 0x18}};

#ifndef MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits NULL
#endif // MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits

//
// Opcodes
//
#define CLR_METHODDC_METHODDCSTART_OPCODE 0x23
#define CLR_METHODDC_METHODDCEND_OPCODE 0x24
#define CLR_METHODDC_METHODDCSTARTVERBOSE_OPCODE 0x27
#define CLR_METHODDC_METHODDCENDVERBOSE_OPCODE 0x28
#define CLR_METHODDC_METHODDCSTARTILTONATIVEMAP_OPCODE 0x29
#define CLR_METHODDC_METHODDCENDILTONATIVEMAP_OPCODE 0x2a
#define CLR_METHODDC_DCSTARTCOMPLETE_OPCODE 0xe
#define CLR_METHODDC_DCENDCOMPLETE_OPCODE 0xf
#define CLR_METHODDC_DCSTARTINIT_OPCODE 0x10
#define CLR_METHODDC_DCENDINIT_OPCODE 0x11
#define CLR_LOADERDC_MODULEDCSTART_OPCODE 0x23
#define CLR_LOADERDC_MODULEDCEND_OPCODE 0x24
#define CLR_LOADERDC_ASSEMBLYDCSTART_OPCODE 0x27
#define CLR_LOADERDC_ASSEMBLYDCEND_OPCODE 0x28
#define CLR_LOADERDC_APPDOMAINDCSTART_OPCODE 0x2b
#define CLR_LOADERDC_APPDOMAINDCEND_OPCODE 0x2c
#define CLR_LOADERDC_DOMAINMODULEDCSTART_OPCODE 0x2e
#define CLR_LOADERDC_DOMAINMODULEDCEND_OPCODE 0x2f
#define CLR_LOADERDC_THREADDC_OPCODE 0x30
#define CLR_RUNDOWNSTACK_STACKWALK_OPCODE 0x52
#define CLR_PERFTRACKRUNDOWN_MODULERANGEDCSTART_OPCODE 0xa
#define CLR_PERFTRACKRUNDOWN_MODULERANGEDCEND_OPCODE 0xb

//
// Tasks
//
#define CLR_METHODRUNDOWN_TASK 0x1
EXTERN_C __declspec(selectany) const GUID CLRMethodRundownId = {0x0bcd91db, 0xf943, 0x454a, {0xa6, 0x62, 0x6e, 0xdb, 0xcf, 0xbb, 0x76, 0xd2}};
#define CLR_LOADERRUNDOWN_TASK 0x2
EXTERN_C __declspec(selectany) const GUID CLRLoaderRundownId = {0x5a54f4df, 0xd302, 0x4fee, {0xa2, 0x11, 0x6c, 0x2c, 0x0c, 0x1d, 0xcb, 0x1a}};
#define CLR_STACKRUNDOWN_TASK 0xb
EXTERN_C __declspec(selectany) const GUID CLRStackRundownId = {0xd3363dc0, 0x243a, 0x4620, {0xa4, 0xd0, 0x8a, 0x07, 0xd7, 0x72, 0xf5, 0x33}};
#define CLR_RuntimeInformation_TASK 0x13
EXTERN_C __declspec(selectany) const GUID CLRRuntimeInformationRundownId = {0xcd7d3e32, 0x65fe, 0x40cd, {0x92, 0x25, 0xa2, 0x57, 0x7d, 0x20, 0x3f, 0xc3}};
#define CLR_PERFTRACKRUNDOWN_TASK 0x14
EXTERN_C __declspec(selectany) const GUID CLRPerfTrackRundownId = {0xeac685f6, 0x2104, 0x4dec, {0x88, 0xfd, 0x91, 0xe4, 0x25, 0x42, 0x21, 0xec}};

//
// Keyword
//
#define CLR_RUNDOWNLOADER_KEYWORD 0x8
#define CLR_RUNDOWNJIT_KEYWORD 0x10
#define CLR_RUNDOWNNGEN_KEYWORD 0x20
#define CLR_RUNDOWNSTART_KEYWORD 0x40
#define CLR_RUNDOWNEND_KEYWORD 0x100
#define CLR_RUNDOWNAPPDOMAINRESOURCEMANAGEMENT_KEYWORD 0x800
#define CLR_RUNDOWNTHREADING_KEYWORD 0x10000
#define CLR_RUNDOWNJITTEDMETHODILTONATIVEMAP_KEYWORD 0x20000
#define CLR_RUNDOWNOVERRIDEANDSUPPRESSNGENEVENTS_KEYWORD 0x40000
#define CLR_RUNDOWNPERFTRACK_KEYWORD 0x20000000
#define CLR_RUNDOWNSTACK_KEYWORD 0x40000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CLRStackWalkDCStart = {0x0, 0x0, 0x0, 0x0, 0x52, 0xb, 0x40000000};
#define CLRStackWalkDCStart_value 0x0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart = {0x8d, 0x0, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart_V1 = {0x8d, 0x1, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_V1_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStart_V2 = {0x8d, 0x2, 0x0, 0x4, 0x23, 0x1, 0x30};
#define MethodDCStart_V2_value 0x8d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd = {0x8e, 0x0, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd_V1 = {0x8e, 0x1, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_V1_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEnd_V2 = {0x8e, 0x2, 0x0, 0x4, 0x24, 0x1, 0x30};
#define MethodDCEnd_V2_value 0x8e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose = {0x8f, 0x0, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose_V1 = {0x8f, 0x1, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_V1_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartVerbose_V2 = {0x8f, 0x2, 0x0, 0x4, 0x27, 0x1, 0x30};
#define MethodDCStartVerbose_V2_value 0x8f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose = {0x90, 0x0, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose_V1 = {0x90, 0x1, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_V1_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndVerbose_V2 = {0x90, 0x2, 0x0, 0x4, 0x28, 0x1, 0x30};
#define MethodDCEndVerbose_V2_value 0x90
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartComplete = {0x91, 0x0, 0x0, 0x4, 0xe, 0x1, 0x20038};
#define DCStartComplete_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartComplete_V1 = {0x91, 0x1, 0x0, 0x4, 0xe, 0x1, 0x20038};
#define DCStartComplete_V1_value 0x91
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndComplete = {0x92, 0x0, 0x0, 0x4, 0xf, 0x1, 0x20038};
#define DCEndComplete_value 0x92
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndComplete_V1 = {0x92, 0x1, 0x0, 0x4, 0xf, 0x1, 0x20038};
#define DCEndComplete_V1_value 0x92
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartInit = {0x93, 0x0, 0x0, 0x4, 0x10, 0x1, 0x20038};
#define DCStartInit_value 0x93
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCStartInit_V1 = {0x93, 0x1, 0x0, 0x4, 0x10, 0x1, 0x20038};
#define DCStartInit_V1_value 0x93
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndInit = {0x94, 0x0, 0x0, 0x4, 0x11, 0x1, 0x20038};
#define DCEndInit_value 0x94
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DCEndInit_V1 = {0x94, 0x1, 0x0, 0x4, 0x11, 0x1, 0x20038};
#define DCEndInit_V1_value 0x94
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCStartILToNativeMap = {0x95, 0x0, 0x0, 0x5, 0x29, 0x1, 0x20000};
#define MethodDCStartILToNativeMap_value 0x95
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MethodDCEndILToNativeMap = {0x96, 0x0, 0x0, 0x5, 0x2a, 0x1, 0x20000};
#define MethodDCEndILToNativeMap_value 0x96
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCStart = {0x97, 0x0, 0x0, 0x4, 0x2e, 0x2, 0x8};
#define DomainModuleDCStart_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCStart_V1 = {0x97, 0x1, 0x0, 0x4, 0x2e, 0x2, 0x8};
#define DomainModuleDCStart_V1_value 0x97
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCEnd = {0x98, 0x0, 0x0, 0x4, 0x2f, 0x2, 0x8};
#define DomainModuleDCEnd_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DomainModuleDCEnd_V1 = {0x98, 0x1, 0x0, 0x4, 0x2f, 0x2, 0x8};
#define DomainModuleDCEnd_V1_value 0x98
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart = {0x99, 0x0, 0x0, 0x4, 0x23, 0x2, 0x8};
#define ModuleDCStart_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart_V1 = {0x99, 0x1, 0x0, 0x4, 0x23, 0x2, 0x20000008};
#define ModuleDCStart_V1_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCStart_V2 = {0x99, 0x2, 0x0, 0x4, 0x23, 0x2, 0x20000008};
#define ModuleDCStart_V2_value 0x99
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd = {0x9a, 0x0, 0x0, 0x4, 0x24, 0x2, 0x8};
#define ModuleDCEnd_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd_V1 = {0x9a, 0x1, 0x0, 0x4, 0x24, 0x2, 0x20000008};
#define ModuleDCEnd_V1_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleDCEnd_V2 = {0x9a, 0x2, 0x0, 0x4, 0x24, 0x2, 0x20000008};
#define ModuleDCEnd_V2_value 0x9a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCStart = {0x9b, 0x0, 0x0, 0x4, 0x27, 0x2, 0x8};
#define AssemblyDCStart_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCStart_V1 = {0x9b, 0x1, 0x0, 0x4, 0x27, 0x2, 0x8};
#define AssemblyDCStart_V1_value 0x9b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCEnd = {0x9c, 0x0, 0x0, 0x4, 0x28, 0x2, 0x8};
#define AssemblyDCEnd_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AssemblyDCEnd_V1 = {0x9c, 0x1, 0x0, 0x4, 0x28, 0x2, 0x8};
#define AssemblyDCEnd_V1_value 0x9c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCStart = {0x9d, 0x0, 0x0, 0x4, 0x2b, 0x2, 0x8};
#define AppDomainDCStart_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCStart_V1 = {0x9d, 0x1, 0x0, 0x4, 0x2b, 0x2, 0x8};
#define AppDomainDCStart_V1_value 0x9d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCEnd = {0x9e, 0x0, 0x0, 0x4, 0x2c, 0x2, 0x8};
#define AppDomainDCEnd_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AppDomainDCEnd_V1 = {0x9e, 0x1, 0x0, 0x4, 0x2c, 0x2, 0x8};
#define AppDomainDCEnd_V1_value 0x9e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadDC = {0x9f, 0x0, 0x0, 0x4, 0x30, 0x2, 0x10800};
#define ThreadDC_value 0x9f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeDCStart = {0xa0, 0x0, 0x0, 0x4, 0xa, 0x14, 0x20000000};
#define ModuleRangeDCStart_value 0xa0
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ModuleRangeDCEnd = {0xa1, 0x0, 0x0, 0x4, 0xb, 0x14, 0x20000000};
#define ModuleRangeDCEnd_value 0xa1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RuntimeInformationDCStart = {0xbb, 0x0, 0x0, 0x4, 0x1, 0x13, 0x0};
#define RuntimeInformationDCStart_value 0xbb

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG Microsoft_Windows_DotNETRuntimeRundownEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG Microsoft_Windows_DotNETRuntimeRundownKeywords[9] = {0x40000000, 0x30, 0x20038, 0x20000, 0x8, 0x20000008, 0x10800, 0x20000000, 0x0};
EXTERN_C __declspec(selectany) const unsigned char Microsoft_Windows_DotNETRuntimeRundownLevels[9] = {0, 4, 4, 5, 4, 4, 4, 4, 4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context = {0, (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits, 0, 0, 0, 0, 0, 0, 9, Microsoft_Windows_DotNETRuntimeRundownEnableBits, Microsoft_Windows_DotNETRuntimeRundownKeywords, Microsoft_Windows_DotNETRuntimeRundownLevels};

//
// Provider REGHANDLE
//
#define Microsoft_Windows_DotNETRuntimeRundownHandle (MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context.RegistrationHandle)

//
// This macro is set to 0, indicating that the EventWrite[Name] macros do not
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_EventWriteActivity 0

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterMicrosoft_Windows_DotNETRuntimeRundown
#define EventRegisterMicrosoft_Windows_DotNETRuntimeRundown() McGenEventRegister(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER, McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown() McGenEventUnregister(&Microsoft_Windows_DotNETRuntimeRundownHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_Microsoft_Windows_DotNETRuntimeRundown));
// - Caller registers the provider, e.g. EventRegisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_Microsoft_Windows_DotNETRuntimeRundown {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use Microsoft_Windows_DotNETRuntimeRundownHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_Microsoft_Windows_DotNETRuntimeRundown;

#define EventRegisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER, pContext)
#define EventRegisterByGuidMicrosoft_Windows_DotNETRuntimeRundown_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterMicrosoft_Windows_DotNETRuntimeRundown_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define Microsoft_Windows_DotNETRuntimeRundownHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_Microsoft_Windows_DotNETRuntimeRundown_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Traits;
    pContext->Context.EnableBitsCount = 9;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = Microsoft_Windows_DotNETRuntimeRundownKeywords;
    pContext->Context.EnableLevel = Microsoft_Windows_DotNETRuntimeRundownLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown*
_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(_In_ McGenContext_Microsoft_Windows_DotNETRuntimeRundown* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "CLRStackWalkDCStart"
//
#define EventEnabledCLRStackWalkDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 0)
#define EventEnabledCLRStackWalkDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 0)

//
// Event write macros for event "CLRStackWalkDCStart"
//
#define EventWriteCLRStackWalkDCStart(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED(CLRStackWalkDCStart) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define EventWriteCLRStackWalkDCStart_AssumeEnabled(ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)
#define EventWriteCLRStackWalkDCStart_ForContext(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, CLRStackWalkDCStart) \
        ? _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&(pContext)->Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) : 0
#define EventWriteCLRStackWalkDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack) \
        _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &CLRStackWalkDCStart, ClrInstanceID, Reserved1, Reserved2, FrameCount, Stack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_CLRStackWalkDCStart _mcgen_PASTE2(McTemplateU0huuqP2_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart"
//
#define EventEnabledMethodDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStart"
//
#define EventWriteMethodDCStart(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCStart) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCStart_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodDCStart_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart(&(pContext)->Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCStart_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart_V1"
//
#define EventEnabledMethodDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStart_V1"
//
#define EventWriteMethodDCStart_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodDCStart_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define EventWriteMethodDCStart_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&(pContext)->Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodDCStart_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart_V1 _mcgen_PASTE2(McTemplateU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStart_V2"
//
#define EventEnabledMethodDCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStart_V2"
//
#define EventWriteMethodDCStart_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCStart_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define EventWriteMethodDCStart_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&(pContext)->Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCStart_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStart_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStart_V2 _mcgen_PASTE2(McTemplateU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd"
//
#define EventEnabledMethodDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEnd"
//
#define EventWriteMethodDCEnd(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED(MethodDCEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCEnd_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)
#define EventWriteMethodDCEnd_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd(&(pContext)->Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) : 0
#define EventWriteMethodDCEnd_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd _mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd_V1"
//
#define EventEnabledMethodDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEnd_V1"
//
#define EventWriteMethodDCEnd_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodDCEnd_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)
#define EventWriteMethodDCEnd_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&(pContext)->Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) : 0
#define EventWriteMethodDCEnd_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd_V1 _mcgen_PASTE2(McTemplateU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEnd_V2"
//
#define EventEnabledMethodDCEnd_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEnd_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEnd_V2"
//
#define EventWriteMethodDCEnd_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCEnd_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)
#define EventWriteMethodDCEnd_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&(pContext)->Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCEnd_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEnd_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEnd_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEnd_V2 _mcgen_PASTE2(McTemplateU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose"
//
#define EventEnabledMethodDCStartVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStartVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStartVerbose"
//
#define EventWriteMethodDCStartVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCStartVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodDCStartVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&(pContext)->Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCStartVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose_V1"
//
#define EventEnabledMethodDCStartVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStartVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStartVerbose_V1"
//
#define EventWriteMethodDCStartVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodDCStartVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define EventWriteMethodDCStartVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&(pContext)->Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodDCStartVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V1 _mcgen_PASTE2(McTemplateU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartVerbose_V2"
//
#define EventEnabledMethodDCStartVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCStartVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCStartVerbose_V2"
//
#define EventWriteMethodDCStartVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCStartVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCStartVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define EventWriteMethodDCStartVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&(pContext)->Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCStartVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartVerbose_V2 _mcgen_PASTE2(McTemplateU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose"
//
#define EventEnabledMethodDCEndVerbose() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEndVerbose_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEndVerbose"
//
#define EventWriteMethodDCEndVerbose(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCEndVerbose_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)
#define EventWriteMethodDCEndVerbose_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&(pContext)->Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) : 0
#define EventWriteMethodDCEndVerbose_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose _mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose_V1"
//
#define EventEnabledMethodDCEndVerbose_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEndVerbose_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEndVerbose_V1"
//
#define EventWriteMethodDCEndVerbose_V1(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodDCEndVerbose_V1_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)
#define EventWriteMethodDCEndVerbose_V1_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose_V1) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&(pContext)->Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) : 0
#define EventWriteMethodDCEndVerbose_V1_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose_V1, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V1 _mcgen_PASTE2(McTemplateU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndVerbose_V2"
//
#define EventEnabledMethodDCEndVerbose_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 1)
#define EventEnabledMethodDCEndVerbose_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 1)

//
// Event write macros for event "MethodDCEndVerbose_V2"
//
#define EventWriteMethodDCEndVerbose_V2(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED(MethodDCEndVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCEndVerbose_V2_AssumeEnabled(MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)
#define EventWriteMethodDCEndVerbose_V2_ForContext(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndVerbose_V2) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&(pContext)->Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) : 0
#define EventWriteMethodDCEndVerbose_V2_ForContextAssumeEnabled(pContext, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndVerbose_V2, MethodID, ModuleID, MethodStartAddress, MethodSize, MethodToken, MethodFlags, MethodNamespace, MethodName, MethodSignature, ClrInstanceID, ReJITID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndVerbose_V2 _mcgen_PASTE2(McTemplateU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartComplete"
//
#define EventEnabledDCStartComplete() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCStartComplete_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCStartComplete"
//
#define EventWriteDCStartComplete() \
        MCGEN_EVENT_ENABLED(DCStartComplete) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete) : 0
#define EventWriteDCStartComplete_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete)
#define EventWriteDCStartComplete_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartComplete) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete(&(pContext)->Context, &DCStartComplete) : 0
#define EventWriteDCStartComplete_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartComplete(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartComplete)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartComplete _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartComplete_V1"
//
#define EventEnabledDCStartComplete_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCStartComplete_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCStartComplete_V1"
//
#define EventWriteDCStartComplete_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCStartComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete_V1, ClrInstanceID) : 0
#define EventWriteDCStartComplete_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartComplete_V1, ClrInstanceID)
#define EventWriteDCStartComplete_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&(pContext)->Context, &DCStartComplete_V1, ClrInstanceID) : 0
#define EventWriteDCStartComplete_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartComplete_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartComplete_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartComplete_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndComplete"
//
#define EventEnabledDCEndComplete() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCEndComplete_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCEndComplete"
//
#define EventWriteDCEndComplete() \
        MCGEN_EVENT_ENABLED(DCEndComplete) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete) : 0
#define EventWriteDCEndComplete_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndComplete(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete)
#define EventWriteDCEndComplete_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndComplete) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete(&(pContext)->Context, &DCEndComplete) : 0
#define EventWriteDCEndComplete_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndComplete(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndComplete)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndComplete _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndComplete_V1"
//
#define EventEnabledDCEndComplete_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCEndComplete_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCEndComplete_V1"
//
#define EventWriteDCEndComplete_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCEndComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete_V1, ClrInstanceID) : 0
#define EventWriteDCEndComplete_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndComplete_V1, ClrInstanceID)
#define EventWriteDCEndComplete_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndComplete_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&(pContext)->Context, &DCEndComplete_V1, ClrInstanceID) : 0
#define EventWriteDCEndComplete_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndComplete_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndComplete_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndComplete_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartInit"
//
#define EventEnabledDCStartInit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCStartInit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCStartInit"
//
#define EventWriteDCStartInit() \
        MCGEN_EVENT_ENABLED(DCStartInit) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit) : 0
#define EventWriteDCStartInit_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCStartInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit)
#define EventWriteDCStartInit_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartInit) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit(&(pContext)->Context, &DCStartInit) : 0
#define EventWriteDCStartInit_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCStartInit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartInit)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartInit _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCStartInit_V1"
//
#define EventEnabledDCStartInit_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCStartInit_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCStartInit_V1"
//
#define EventWriteDCStartInit_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCStartInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit_V1, ClrInstanceID) : 0
#define EventWriteDCStartInit_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCStartInit_V1, ClrInstanceID)
#define EventWriteDCStartInit_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCStartInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCStartInit_V1(&(pContext)->Context, &DCStartInit_V1, ClrInstanceID) : 0
#define EventWriteDCStartInit_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCStartInit_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCStartInit_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCStartInit_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndInit"
//
#define EventEnabledDCEndInit() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCEndInit_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCEndInit"
//
#define EventWriteDCEndInit() \
        MCGEN_EVENT_ENABLED(DCEndInit) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit) : 0
#define EventWriteDCEndInit_AssumeEnabled() \
        _mcgen_TEMPLATE_FOR_DCEndInit(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit)
#define EventWriteDCEndInit_ForContext(pContext) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndInit) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit(&(pContext)->Context, &DCEndInit) : 0
#define EventWriteDCEndInit_ForContextAssumeEnabled(pContext) \
        _mcgen_TEMPLATE_FOR_DCEndInit(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndInit)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndInit _mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DCEndInit_V1"
//
#define EventEnabledDCEndInit_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 2)
#define EventEnabledDCEndInit_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 2)

//
// Event write macros for event "DCEndInit_V1"
//
#define EventWriteDCEndInit_V1(ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DCEndInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit_V1, ClrInstanceID) : 0
#define EventWriteDCEndInit_V1_AssumeEnabled(ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndInit_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DCEndInit_V1, ClrInstanceID)
#define EventWriteDCEndInit_V1_ForContext(pContext, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DCEndInit_V1) \
        ? _mcgen_TEMPLATE_FOR_DCEndInit_V1(&(pContext)->Context, &DCEndInit_V1, ClrInstanceID) : 0
#define EventWriteDCEndInit_V1_ForContextAssumeEnabled(pContext, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DCEndInit_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DCEndInit_V1, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DCEndInit_V1 _mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCStartILToNativeMap"
//
#define EventEnabledMethodDCStartILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventEnabledMethodDCStartILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "MethodDCStartILToNativeMap"
//
#define EventWriteMethodDCStartILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCStartILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodDCStartILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define EventWriteMethodDCStartILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCStartILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&(pContext)->Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodDCStartILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCStartILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCStartILToNativeMap _mcgen_PASTE2(McTemplateU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "MethodDCEndILToNativeMap"
//
#define EventEnabledMethodDCEndILToNativeMap() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 3)
#define EventEnabledMethodDCEndILToNativeMap_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 3)

//
// Event write macros for event "MethodDCEndILToNativeMap"
//
#define EventWriteMethodDCEndILToNativeMap(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(MethodDCEndILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodDCEndILToNativeMap_AssumeEnabled(MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)
#define EventWriteMethodDCEndILToNativeMap_ForContext(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, MethodDCEndILToNativeMap) \
        ? _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&(pContext)->Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) : 0
#define EventWriteMethodDCEndILToNativeMap_ForContextAssumeEnabled(pContext, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &MethodDCEndILToNativeMap, MethodID, ReJITID, MethodExtent, CountOfMapEntries, ILOffsets, NativeOffsets, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_MethodDCEndILToNativeMap _mcgen_PASTE2(McTemplateU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCStart"
//
#define EventEnabledDomainModuleDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledDomainModuleDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "DomainModuleDCStart"
//
#define EventWriteDomainModuleDCStart(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleDCStart_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteDomainModuleDCStart_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&(pContext)->Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleDCStart_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCStart, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCStart _mcgen_PASTE2(McTemplateU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCStart_V1"
//
#define EventEnabledDomainModuleDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledDomainModuleDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "DomainModuleDCStart_V1"
//
#define EventWriteDomainModuleDCStart_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleDCStart_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteDomainModuleDCStart_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&(pContext)->Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleDCStart_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCStart_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCStart_V1 _mcgen_PASTE2(McTemplateU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCEnd"
//
#define EventEnabledDomainModuleDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledDomainModuleDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "DomainModuleDCEnd"
//
#define EventWriteDomainModuleDCEnd(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(DomainModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleDCEnd_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteDomainModuleDCEnd_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&(pContext)->Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteDomainModuleDCEnd_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCEnd, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCEnd _mcgen_PASTE2(McTemplateU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DomainModuleDCEnd_V1"
//
#define EventEnabledDomainModuleDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledDomainModuleDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "DomainModuleDCEnd_V1"
//
#define EventWriteDomainModuleDCEnd_V1(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DomainModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleDCEnd_V1_AssumeEnabled(ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteDomainModuleDCEnd_V1_ForContext(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DomainModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&(pContext)->Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteDomainModuleDCEnd_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &DomainModuleDCEnd_V1, ModuleID, AssemblyID, AppDomainID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DomainModuleDCEnd_V1 _mcgen_PASTE2(McTemplateU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart"
//
#define EventEnabledModuleDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledModuleDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "ModuleDCStart"
//
#define EventWriteModuleDCStart(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCStart_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleDCStart_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart(&(pContext)->Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCStart_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart_V1"
//
#define EventEnabledModuleDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventEnabledModuleDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCStart_V1"
//
#define EventWriteModuleDCStart_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleDCStart_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteModuleDCStart_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&(pContext)->Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleDCStart_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart_V1 _mcgen_PASTE2(McTemplateU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCStart_V2"
//
#define EventEnabledModuleDCStart_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventEnabledModuleDCStart_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCStart_V2"
//
#define EventWriteModuleDCStart_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleDCStart_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define EventWriteModuleDCStart_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCStart_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&(pContext)->Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleDCStart_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCStart_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCStart_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCStart_V2 _mcgen_PASTE2(McTemplateU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd"
//
#define EventEnabledModuleDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledModuleDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "ModuleDCEnd"
//
#define EventWriteModuleDCEnd(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCEnd_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)
#define EventWriteModuleDCEnd_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd(&(pContext)->Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) : 0
#define EventWriteModuleDCEnd_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd _mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd_V1"
//
#define EventEnabledModuleDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventEnabledModuleDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCEnd_V1"
//
#define EventWriteModuleDCEnd_V1(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleDCEnd_V1_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)
#define EventWriteModuleDCEnd_V1_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&(pContext)->Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) : 0
#define EventWriteModuleDCEnd_V1_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd_V1, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd_V1 _mcgen_PASTE2(McTemplateU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleDCEnd_V2"
//
#define EventEnabledModuleDCEnd_V2() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 5)
#define EventEnabledModuleDCEnd_V2_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 5)

//
// Event write macros for event "ModuleDCEnd_V2"
//
#define EventWriteModuleDCEnd_V2(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED(ModuleDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleDCEnd_V2_AssumeEnabled(ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)
#define EventWriteModuleDCEnd_V2_ForContext(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleDCEnd_V2) \
        ? _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&(pContext)->Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) : 0
#define EventWriteModuleDCEnd_V2_ForContextAssumeEnabled(pContext, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath) \
        _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleDCEnd_V2, ModuleID, AssemblyID, ModuleFlags, Reserved1, ModuleILPath, ModuleNativePath, ClrInstanceID, ManagedPdbSignature, ManagedPdbAge, ManagedPdbBuildPath, NativePdbSignature, NativePdbAge, NativePdbBuildPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleDCEnd_V2 _mcgen_PASTE2(McTemplateU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCStart"
//
#define EventEnabledAssemblyDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAssemblyDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AssemblyDCStart"
//
#define EventWriteAssemblyDCStart(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyDCStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyDCStart_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define EventWriteAssemblyDCStart_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCStart) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart(&(pContext)->Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyDCStart_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCStart, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCStart _mcgen_PASTE2(McTemplateU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCStart_V1"
//
#define EventEnabledAssemblyDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAssemblyDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AssemblyDCStart_V1"
//
#define EventWriteAssemblyDCStart_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyDCStart_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteAssemblyDCStart_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&(pContext)->Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyDCStart_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCStart_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCStart_V1 _mcgen_PASTE2(McTemplateU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCEnd"
//
#define EventEnabledAssemblyDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAssemblyDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AssemblyDCEnd"
//
#define EventWriteAssemblyDCEnd(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED(AssemblyDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyDCEnd_AssumeEnabled(AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)
#define EventWriteAssemblyDCEnd_ForContext(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&(pContext)->Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) : 0
#define EventWriteAssemblyDCEnd_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCEnd, AssemblyID, AppDomainID, AssemblyFlags, FullyQualifiedAssemblyName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCEnd _mcgen_PASTE2(McTemplateU0xxqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AssemblyDCEnd_V1"
//
#define EventEnabledAssemblyDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAssemblyDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AssemblyDCEnd_V1"
//
#define EventWriteAssemblyDCEnd_V1(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AssemblyDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyDCEnd_V1_AssumeEnabled(AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)
#define EventWriteAssemblyDCEnd_V1_ForContext(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AssemblyDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&(pContext)->Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) : 0
#define EventWriteAssemblyDCEnd_V1_ForContextAssumeEnabled(pContext, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AssemblyDCEnd_V1, AssemblyID, AppDomainID, BindingID, AssemblyFlags, FullyQualifiedAssemblyName, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AssemblyDCEnd_V1 _mcgen_PASTE2(McTemplateU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCStart"
//
#define EventEnabledAppDomainDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAppDomainDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AppDomainDCStart"
//
#define EventWriteAppDomainDCStart(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainDCStart) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainDCStart_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName)
#define EventWriteAppDomainDCStart_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCStart) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart(&(pContext)->Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainDCStart_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCStart, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCStart _mcgen_PASTE2(McTemplateU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCStart_V1"
//
#define EventEnabledAppDomainDCStart_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAppDomainDCStart_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AppDomainDCStart_V1"
//
#define EventWriteAppDomainDCStart_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainDCStart_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define EventWriteAppDomainDCStart_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCStart_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&(pContext)->Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainDCStart_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCStart_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCStart_V1 _mcgen_PASTE2(McTemplateU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCEnd"
//
#define EventEnabledAppDomainDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAppDomainDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AppDomainDCEnd"
//
#define EventWriteAppDomainDCEnd(AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED(AppDomainDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainDCEnd_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName)
#define EventWriteAppDomainDCEnd_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCEnd) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&(pContext)->Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName) : 0
#define EventWriteAppDomainDCEnd_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCEnd, AppDomainID, AppDomainFlags, AppDomainName)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCEnd _mcgen_PASTE2(McTemplateU0xqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AppDomainDCEnd_V1"
//
#define EventEnabledAppDomainDCEnd_V1() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 4)
#define EventEnabledAppDomainDCEnd_V1_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 4)

//
// Event write macros for event "AppDomainDCEnd_V1"
//
#define EventWriteAppDomainDCEnd_V1(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(AppDomainDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainDCEnd_V1_AssumeEnabled(AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)
#define EventWriteAppDomainDCEnd_V1_ForContext(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AppDomainDCEnd_V1) \
        ? _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&(pContext)->Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) : 0
#define EventWriteAppDomainDCEnd_V1_ForContextAssumeEnabled(pContext, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &AppDomainDCEnd_V1, AppDomainID, AppDomainFlags, AppDomainName, AppDomainIndex, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AppDomainDCEnd_V1 _mcgen_PASTE2(McTemplateU0xqzqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadDC"
//
#define EventEnabledThreadDC() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 6)
#define EventEnabledThreadDC_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 6)

//
// Event write macros for event "ThreadDC"
//
#define EventWriteThreadDC(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(ThreadDC) \
        ? _mcgen_TEMPLATE_FOR_ThreadDC(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define EventWriteThreadDC_AssumeEnabled(ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDC(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)
#define EventWriteThreadDC_ForContext(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadDC) \
        ? _mcgen_TEMPLATE_FOR_ThreadDC(&(pContext)->Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) : 0
#define EventWriteThreadDC_ForContextAssumeEnabled(pContext, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_ThreadDC(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ThreadDC, ManagedThreadID, AppDomainID, Flags, ManagedThreadIndex, OSThreadID, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadDC _mcgen_PASTE2(McTemplateU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeDCStart"
//
#define EventEnabledModuleRangeDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 7)
#define EventEnabledModuleRangeDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 7)

//
// Event write macros for event "ModuleRangeDCStart"
//
#define EventWriteModuleRangeDCStart(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeDCStart_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define EventWriteModuleRangeDCStart_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeDCStart) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&(pContext)->Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleRangeDCStart, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeDCStart _mcgen_PASTE2(McTemplateU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ModuleRangeDCEnd"
//
#define EventEnabledModuleRangeDCEnd() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 7)
#define EventEnabledModuleRangeDCEnd_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 7)

//
// Event write macros for event "ModuleRangeDCEnd"
//
#define EventWriteModuleRangeDCEnd(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED(ModuleRangeDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeDCEnd_AssumeEnabled(ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)
#define EventWriteModuleRangeDCEnd_ForContext(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ModuleRangeDCEnd) \
        ? _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&(pContext)->Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) : 0
#define EventWriteModuleRangeDCEnd_ForContextAssumeEnabled(pContext, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType) \
        _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &ModuleRangeDCEnd, ClrInstanceID, ModuleID, RangeBegin, RangeSize, RangeType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ModuleRangeDCEnd _mcgen_PASTE2(McTemplateU0hxqqu_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RuntimeInformationDCStart"
//
#define EventEnabledRuntimeInformationDCStart() _mcgen_EVENT_BIT_SET(Microsoft_Windows_DotNETRuntimeRundownEnableBits, 8)
#define EventEnabledRuntimeInformationDCStart_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->EnableBits, 8)

//
// Event write macros for event "RuntimeInformationDCStart"
//
#define EventWriteRuntimeInformationDCStart(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED(RuntimeInformationDCStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define EventWriteRuntimeInformationDCStart_AssumeEnabled(ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&MICROSOFT_WINDOWS_DOTNETRUNTIME_RUNDOWN_PROVIDER_Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)
#define EventWriteRuntimeInformationDCStart_ForContext(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RuntimeInformationDCStart) \
        ? _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&(pContext)->Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) : 0
#define EventWriteRuntimeInformationDCStart_ForContextAssumeEnabled(pContext, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath) \
        _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart(&_mcgen_CheckContextType_Microsoft_Windows_DotNETRuntimeRundown(pContext)->Context, &RuntimeInformationDCStart, ClrInstanceID, Sku, BclMajorVersion, BclMinorVersion, BclBuildNumber, BclQfeNumber, VMMajorVersion, VMMinorVersion, VMBuildNumber, VMQfeNumber, StartupFlags, StartupMode, CommandLine, ComObjectGuid, RuntimeDllPath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RuntimeInformationDCStart _mcgen_PASTE2(McTemplateU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions
//

//
// Function for template "(default)" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0_def
#define McTemplateU0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor
    )
{
#define McTemplateU0_ARGCOUNT 0

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0_ARGCOUNT + 1];

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentStats" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ggggggggghh_def
#define McTemplateU0ggggggggghh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ggggggggghh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const double  _Arg1,
    _In_ const double  _Arg2,
    _In_ const double  _Arg3,
    _In_ const double  _Arg4,
    _In_ const double  _Arg5,
    _In_ const double  _Arg6,
    _In_ const double  _Arg7,
    _In_ const double  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned short  _Arg10
    )
{
#define McTemplateU0ggggggggghh_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ggggggggghh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const double)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const double)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const double)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const double)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const double)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const double)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const double)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const double)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ggggggggghh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ggggggggghh_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentSample" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0gh_def
#define McTemplateU0gh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0gh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0gh_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0gh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0gh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0gh_def

//
// Function for template "ThreadPoolWorkerThreadAdjustmentAdjustment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0gqqh_def
#define McTemplateU0gqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0gqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const double  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0gqqh_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0gqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const double)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0gqqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0gqqh_def

//
// Function for template "GCNoUserData" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0h_def
#define McTemplateU0h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0
    )
{
#define McTemplateU0h_ARGCOUNT 1

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0h_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0h_def

//
// Function for template "RuntimeInformation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0hhhhhhhhhhquzjz_def
#define McTemplateU0hhhhhhhhhhquzjz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0hhhhhhhhhhquzjz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned short  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned short  _Arg7,
    _In_ const unsigned short  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned char  _Arg11,
    _In_opt_ PCWSTR  _Arg12,
    _In_ const GUID*  _Arg13,
    _In_opt_ PCWSTR  _Arg14
    )
{
#define McTemplateU0hhhhhhhhhhquzjz_ARGCOUNT 15

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0hhhhhhhhhhquzjz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[14],_Arg13, sizeof(GUID)  );

    EventDataDescCreate(&EventData[15],
                        (_Arg14 != NULL) ? _Arg14 : L"NULL",
                        (_Arg14 != NULL) ? (ULONG)((wcslen(_Arg14) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0hhhhhhhhhhquzjz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0hhhhhhhhhhquzjz_def

//
// Function for template "GCPerHeapHistory_V3" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0hppppppqqqqqqpqNR14_def
#define McTemplateU0hppppppqqqqqqpqNR14_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0hppppppqqqqqqpqNR14_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_opt_ const void*  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ const void*  _Arg5,
    _In_opt_ const void*  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_ const unsigned int  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12,
    _In_opt_ const void*  _Arg13,
    _In_ const unsigned int  _Arg14,
    _In_ ULONG _Arg15_Len_,
    _In_ const void*  _Arg15
    )
{
#define McTemplateU0hppppppqqqqqqpqNR14_ARGCOUNT 16

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0hppppppqqqqqqpqNR14_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const void*)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const void*)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const void*)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const void*)  );

    EventDataDescCreate(&EventData[15],&_Arg14, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[16],_Arg15, _Arg14 * _Arg15_Len_);

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0hppppppqqqqqqpqNR14_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0hppppppqqqqqqpqNR14_def

//
// Function for template "ClrStackWalk" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0huuqP2_def
#define McTemplateU0huuqP2_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0huuqP2_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned char  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_reads_(2) const void* *_Arg4
    )
{
#define McTemplateU0huuqP2_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0huuqP2_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5], _Arg4, sizeof(const void*)*2);

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0huuqP2_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0huuqP2_def

//
// Function for template "ModuleRange" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0hxqqu_def
#define McTemplateU0hxqqu_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0hxqqu_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned char  _Arg4
    )
{
#define McTemplateU0hxqqu_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0hxqqu_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned char)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0hxqqu_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0hxqqu_def

//
// Function for template "ILStubGenerated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0hxxqqzzzzzz_def
#define McTemplateU0hxxqqzzzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0hxxqqzzzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_opt_ PCWSTR  _Arg10
    )
{
#define McTemplateU0hxxqqzzzzzz_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0hxxqqzzzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0hxxqqzzzzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0hxxqqzzzzzz_def

//
// Function for template "ILStubCacheHit" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0hxxqzzz_def
#define McTemplateU0hxxqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0hxxqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned short  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateU0hxxqzzz_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0hxxqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0hxxqzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0hxxqzzz_def

//
// Function for template "DestroyGCHandle" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ph_def
#define McTemplateU0ph_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ph_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0ph_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ph_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ph_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ph_def

//
// Function for template "FinalizeObject" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0pph_def
#define McTemplateU0pph_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0pph_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateU0pph_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0pph_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0pph_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0pph_def

//
// Function for template "SetGCHandle" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ppqqxh_def
#define McTemplateU0ppqqxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ppqqxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateU0ppqqxh_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ppqqxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ppqqxh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ppqqxh_def

//
// Function for template "GCSampledObjectAllocation" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ppqxh_def
#define McTemplateU0ppqxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ppqxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateU0ppqxh_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ppqxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ppqxh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ppqxh_def

//
// Function for template "ThreadPoolIOWorkEnqueue" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ppth_def
#define McTemplateU0ppth_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ppth_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const signed int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0ppth_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ppth_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ppth_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ppth_def

//
// Function for template "PinObjectAtGCTime" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0ppxzh_def
#define McTemplateU0ppxzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0ppxzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const void*  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateU0ppxzh_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0ppxzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const void*)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0ppxzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0ppxzh_def

//
// Function for template "GCFinalizersEnd" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0q_def
#define McTemplateU0q_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0q_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0
    )
{
#define McTemplateU0q_ARGCOUNT 1

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0q_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0q_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0q_def

//
// Function for template "GCEnd" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qh_def
#define McTemplateU0qh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0qh_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qh_def

//
// Function for template "BulkType" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qhNR0_def
#define McTemplateU0qhNR0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qhNR0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ ULONG _Arg2_Len_,
    _In_ const void*  _Arg2
    )
{
#define McTemplateU0qhNR0_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qhNR0_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],_Arg2, _Arg0 * _Arg2_Len_);

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qhNR0_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qhNR0_def

//
// Function for template "GCMarkWithType" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qhqx_def
#define McTemplateU0qhqx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qhqx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned short  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned __int64  _Arg3
    )
{
#define McTemplateU0qhqx_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qhqx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qhqx_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qhqx_def

//
// Function for template "GCStart" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qq_def
#define McTemplateU0qq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1
    )
{
#define McTemplateU0qq_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qq_def

//
// Function for template "GCEnd_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqh_def
#define McTemplateU0qqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateU0qqh_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqh_def

//
// Function for template "GCBulkRootEdge" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqhNR1_def
#define McTemplateU0qqhNR1_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqhNR1_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ ULONG _Arg3_Len_,
    _In_ const void*  _Arg3
    )
{
#define McTemplateU0qqhNR1_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqhNR1_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],_Arg3, _Arg1 * _Arg3_Len_);

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqhNR1_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqhNR1_def

//
// Function for template "GCAllocationTick_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqhxpzq_def
#define McTemplateU0qqhxpzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqhxpzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6
    )
{
#define McTemplateU0qqhxpzq_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqhxpzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqhxpzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqhxpzq_def

//
// Function for template "GCAllocationTick_V3" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqhxpzqp_def
#define McTemplateU0qqhxpzqp_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqhxpzqp_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ const void*  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ const void*  _Arg7
    )
{
#define McTemplateU0qqhxpzqp_ARGCOUNT 8

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqhxpzqp_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const void*)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const void*)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqhxpzqp_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqhxpzqp_def

//
// Function for template "GCJoin_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqqhq_def
#define McTemplateU0qqqhq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqqhq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_ const unsigned int  _Arg4
    )
{
#define McTemplateU0qqqhq_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqqhq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqqhq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqqhq_def

//
// Function for template "GCStart_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqqqh_def
#define McTemplateU0qqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateU0qqqqh_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqqqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqqqh_def

//
// Function for template "GCStart_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqqqhx_def
#define McTemplateU0qqqqhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqqqhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned __int64  _Arg5
    )
{
#define McTemplateU0qqqqhx_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqqqhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqqqhx_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqqqhx_def

//
// Function for template "StrongNameVerification" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqz_def
#define McTemplateU0qqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateU0qqz_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqz_def

//
// Function for template "StrongNameVerification_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qqzh_def
#define McTemplateU0qqzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qqzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0qqzh_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qqzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qqzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qqzh_def

//
// Function for template "GCBulkRootStaticVar" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0qxhNR0_def
#define McTemplateU0qxhNR0_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0qxhNR0_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned int  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned short  _Arg2,
    _In_ ULONG _Arg3_Len_,
    _In_ const void*  _Arg3
    )
{
#define McTemplateU0qxhNR0_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0qxhNR0_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[4],_Arg3, _Arg0 * _Arg3_Len_);

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0qxhNR0_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0qxhNR0_def

//
// Function for template "Contention" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0uh_def
#define McTemplateU0uh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0uh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0uh_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0uh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0uh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0uh_def

//
// Function for template "GCGenerationRange" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0upxxh_def
#define McTemplateU0upxxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0upxxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned char  _Arg0,
    _In_opt_ const void*  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateU0upxxh_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0upxxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const void*)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0upxxh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0upxxh_def

//
// Function for template "GCFreeSegment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0x_def
#define McTemplateU0x_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0x_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0
    )
{
#define McTemplateU0x_ARGCOUNT 1

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0x_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0x_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0x_def

//
// Function for template "GCGlobalHeap_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xdqqqqhqq_def
#define McTemplateU0xdqqqqhqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xdqqqqhqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned int  _Arg8
    )
{
#define McTemplateU0xdqqqqhqq_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xdqqqqhqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xdqqqqhqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xdqqqqhqq_def

//
// Function for template "GCFreeSegment_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xh_def
#define McTemplateU0xh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0xh_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xh_def

//
// Function for template "AppDomainLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xqz_def
#define McTemplateU0xqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2
    )
{
#define McTemplateU0xqz_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xqz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xqz_def

//
// Function for template "AppDomainLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xqzqh_def
#define McTemplateU0xqzqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xqzqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4
    )
{
#define McTemplateU0xqzqh_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xqzqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xqzqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xqzqh_def

//
// Function for template "AppDomainMemAllocated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxh_def
#define McTemplateU0xxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned short  _Arg2
    )
{
#define McTemplateU0xxh_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxh_def

//
// Function for template "GCCreateSegment" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxq_def
#define McTemplateU0xxq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2
    )
{
#define McTemplateU0xxq_ARGCOUNT 3

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxq_def

//
// Function for template "GCCreateSegment_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqh_def
#define McTemplateU0xxqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0xxqh_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqh_def

//
// Function for template "ThreadCreated" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqqh_def
#define McTemplateU0xxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateU0xxqqqh_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqqh_def

//
// Function for template "ModuleLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqzz_def
#define McTemplateU0xxqqzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5
    )
{
#define McTemplateU0xxqqzz_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqzz_def

//
// Function for template "ModuleLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqzzh_def
#define McTemplateU0xxqqzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateU0xxqqzzh_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqzzh_def

//
// Function for template "ModuleLoadUnload_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqzzhjqzjqz_def
#define McTemplateU0xxqqzzhjqzjqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqzzhjqzjqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const GUID*  _Arg7,
    _In_ const unsigned int  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_ const GUID*  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_opt_ PCWSTR  _Arg12
    )
{
#define McTemplateU0xxqqzzhjqzjqz_ARGCOUNT 13

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqzzhjqzjqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],_Arg7, sizeof(GUID)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],_Arg10, sizeof(GUID)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqzzhjqzjqz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqzzhjqzjqz_def

//
// Function for template "MethodJittingStarted" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqzzz_def
#define McTemplateU0xxqqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateU0xxqqzzz_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqzzz_def

//
// Function for template "MethodJittingStarted_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqqzzzh_def
#define McTemplateU0xxqqzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqqzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateU0xxqqzzzh_ARGCOUNT 8

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqqzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqqzzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqqzzzh_def

//
// Function for template "AssemblyLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxqz_def
#define McTemplateU0xxqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_opt_ PCWSTR  _Arg3
    )
{
#define McTemplateU0xxqz_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxqz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxqz_def

//
// Function for template "MethodILToNativeMap" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxuhQR3QR3h_def
#define McTemplateU0xxuhQR3QR3h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxuhQR3QR3h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned char  _Arg2,
    _In_ const unsigned short  _Arg3,
    _In_reads_(_Arg3) const unsigned int *_Arg4,
    _In_reads_(_Arg3) const unsigned int *_Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateU0xxuhQR3QR3h_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxuhQR3QR3h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned char)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[5], _Arg4, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[6], _Arg5, sizeof(const unsigned int)*_Arg3);

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxuhQR3QR3h_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxuhQR3QR3h_def

//
// Function for template "AppDomainMemSurvived" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxh_def
#define McTemplateU0xxxh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0xxxh_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxh_def

//
// Function for template "MethodLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqq_def
#define McTemplateU0xxxqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5
    )
{
#define McTemplateU0xxxqqq_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqq_def

//
// Function for template "MethodLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqqh_def
#define McTemplateU0xxxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6
    )
{
#define McTemplateU0xxxqqqh_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqqh_def

//
// Function for template "MethodLoadUnload_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqqhx_def
#define McTemplateU0xxxqqqhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqqhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_ const unsigned short  _Arg6,
    _In_ const unsigned __int64  _Arg7
    )
{
#define McTemplateU0xxxqqqhx_ARGCOUNT 8

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqqhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqqhx_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqqhx_def

//
// Function for template "MethodLoadUnloadVerbose" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqqzzz_def
#define McTemplateU0xxxqqqzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqqzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8
    )
{
#define McTemplateU0xxxqqqzzz_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqqzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqqzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqqzzz_def

//
// Function for template "MethodLoadUnloadVerbose_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqqzzzh_def
#define McTemplateU0xxxqqqzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqqzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9
    )
{
#define McTemplateU0xxxqqqzzzh_ARGCOUNT 10

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqqzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqqzzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqqzzzh_def

//
// Function for template "MethodLoadUnloadVerbose_V2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqqzzzhx_def
#define McTemplateU0xxxqqqzzzhx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqqzzzhx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9,
    _In_ const unsigned __int64  _Arg10
    )
{
#define McTemplateU0xxxqqqzzzhx_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqqzzzhx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqqzzzhx_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqqzzzhx_def

//
// Function for template "DomainModuleLoadUnload" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqzz_def
#define McTemplateU0xxxqqzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateU0xxxqqzz_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqzz_def

//
// Function for template "DomainModuleLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqqzzh_def
#define McTemplateU0xxxqqzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqqzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned short  _Arg7
    )
{
#define McTemplateU0xxxqqzzh_ARGCOUNT 8

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqqzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqqzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqqzzh_def

//
// Function for template "AssemblyLoadUnload_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxqzh_def
#define McTemplateU0xxxqzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxqzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateU0xxxqzh_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxqzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxqzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxqzh_def

//
// Function for template "GCHeapStats" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxxxxxxxxqqq_def
#define McTemplateU0xxxxxxxxxxqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxxxxxxxxqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12
    )
{
#define McTemplateU0xxxxxxxxxxqqq_ARGCOUNT 13

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxxxxxxxxqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxxxxxxxxqqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxxxxxxxxqqq_def

//
// Function for template "GCHeapStats_V1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxxxxxxxxxqqqh_def
#define McTemplateU0xxxxxxxxxxqqqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxxxxxxxxxqqqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned int  _Arg11,
    _In_ const unsigned int  _Arg12,
    _In_ const unsigned short  _Arg13
    )
{
#define McTemplateU0xxxxxxxxxxqqqh_ARGCOUNT 14

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxxxxxxxxxqqqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[13],&_Arg12, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxxxxxxxxxqqqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxxxxxxxxxqqqh_def

//
// Function for template "ExceptionHandling" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0xxzh_def
#define McTemplateU0xxzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0xxzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_ const unsigned __int64  _Arg0,
    _In_ const unsigned __int64  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0xxzh_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0xxzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],&_Arg0, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0xxzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0xxzh_def

//
// Function for template "GCLoaded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zh_def
#define McTemplateU0zh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned short  _Arg1
    )
{
#define McTemplateU0zh_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zh_def

//
// Function for template "GCDynamicEvent" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zqbr1h_def
#define McTemplateU0zqbr1h_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zqbr1h_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_reads_(_Arg1) const unsigned char*  _Arg2,
    _In_ const unsigned short  _Arg3
    )
{
#define McTemplateU0zqbr1h_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zqbr1h_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],_Arg2, (ULONG)sizeof(char)*_Arg1);

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zqbr1h_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zqbr1h_def

//
// Function for template "Exception" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zzpqhh_def
#define McTemplateU0zzpqhh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zzpqhh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ const void*  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateU0zzpqhh_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zzpqhh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const void*)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zzpqhh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zzpqhh_def

//
// Function for template "MethodJitInliningSucceeded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zzzzzzzzzh_def
#define McTemplateU0zzzzzzzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zzzzzzzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned short  _Arg9
    )
{
#define McTemplateU0zzzzzzzzzh_ARGCOUNT 10

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zzzzzzzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zzzzzzzzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zzzzzzzzzh_def

//
// Function for template "MethodJitTailCallSucceeded" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zzzzzzzzztqh_def
#define McTemplateU0zzzzzzzzztqh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zzzzzzzzztqh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_ const unsigned int  _Arg10,
    _In_ const unsigned short  _Arg11
    )
{
#define McTemplateU0zzzzzzzzztqh_ARGCOUNT 12

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zzzzzzzzztqh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zzzzzzzzztqh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zzzzzzzzztqh_def

//
// Function for template "MethodJitInliningFailed" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateU0zzzzzzzzztsh_def
#define McTemplateU0zzzzzzzzztsh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateU0zzzzzzzzztsh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ PCWSTR  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_opt_ PCSTR  _Arg10,
    _In_ const unsigned short  _Arg11
    )
{
#define McTemplateU0zzzzzzzzztsh_ARGCOUNT 12

    EVENT_DATA_DESCRIPTOR EventData[McTemplateU0zzzzzzzzztsh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],
                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : "NULL",
                        (_Arg10 != NULL) ? (ULONG)((strlen(_Arg10) + 1) * sizeof(char)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, NULL, McTemplateU0zzzzzzzzztsh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateU0zzzzzzzzztsh_def

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
}
#endif

#define MSG_RuntimePublisher_GCKeywordMessage 0x10000001L
#define MSG_RuntimePublisher_GCHandleKeywordMessage 0x10000002L
#define MSG_RuntimePublisher_FusionKeywordMessage 0x10000003L
#define MSG_RuntimePublisher_LoaderKeywordMessage 0x10000004L
#define MSG_RuntimePublisher_JitKeywordMessage 0x10000005L
#define MSG_RuntimePublisher_NGenKeywordMessage 0x10000006L
#define MSG_RuntimePublisher_StartEnumerationKeywordMessage 0x10000007L
#define MSG_RuntimePublisher_EndEnumerationKeywordMessage 0x10000008L
#define MSG_RuntimePublisher_SecurityKeywordMessage 0x1000000BL
#define MSG_RuntimePublisher_AppDomainResourceManagementKeywordMessage 0x1000000CL
#define MSG_RuntimePublisher_JitTracingKeywordMessage 0x1000000DL
#define MSG_RuntimePublisher_InteropKeywordMessage 0x1000000EL
#define MSG_RuntimePublisher_ContentionKeywordMessage 0x1000000FL
#define MSG_RuntimePublisher_ExceptionKeywordMessage 0x10000010L
#define MSG_RuntimePublisher_ThreadingKeywordMessage 0x10000011L
#define MSG_RuntimePublisher_JittedMethodILToNativeMapKeywordMessage 0x10000012L
#define MSG_RuntimePublisher_OverrideAndSuppressNGenEventsKeywordMessage 0x10000013L
#define MSG_RuntimePublisher_TypeKeywordMessage 0x10000014L
#define MSG_RuntimePublisher_GCHeapDumpKeywordMessage 0x10000015L
#define MSG_RuntimePublisher_GCSampledObjectAllocationHighKeywordMessage 0x10000016L
#define MSG_RuntimePublisher_GCHeapSurvivalAndMovementKeywordMessage 0x10000017L
#define MSG_RuntimePublisher_GCHeapCollectKeyword 0x10000018L
#define MSG_RuntimePublisher_GCHeapAndTypeNamesKeyword 0x10000019L
#define MSG_RuntimePublisher_GCSampledObjectAllocationLowKeywordMessage 0x1000001AL
#define MSG_RuntimePublisher_PerfTrackKeywordMessage 0x1000001EL
#define MSG_RuntimePublisher_StackKeywordMessage 0x1000001FL
#define MSG_RuntimePublisher_ThreadTransferKeywordMessage 0x10000020L
#define MSG_RuntimePublisher_DebuggerKeywordMessage 0x10000021L
#define MSG_RuntimePublisher_MonitoringKeywordMessage 0x10000022L
#define MSG_RundownPublisher_LoaderKeywordMessage 0x11000004L
#define MSG_RundownPublisher_JitKeywordMessage 0x11000005L
#define MSG_RundownPublisher_NGenKeywordMessage 0x11000006L
#define MSG_RundownPublisher_StartRundownKeywordMessage 0x11000007L
#define MSG_RundownPublisher_EndRundownKeywordMessage 0x11000009L
#define MSG_RuntimePublisher_AppDomainResourceManagementRundownKeywordMessage 0x1100000CL
#define MSG_RundownPublisher_ThreadingKeywordMessage 0x11000011L
#define MSG_RundownPublisher_JittedMethodILToNativeMapRundownKeywordMessage 0x11000012L
#define MSG_RundownPublisher_OverrideAndSuppressNGenEventsRundownKeywordMessage 0x11000013L
#define MSG_RundownPublisher_PerfTrackRundownKeywordMessage 0x1100001EL
#define MSG_RundownPublisher_StackKeywordMessage 0x1100001FL
#define MSG_RuntimePublisher_GCSuspendEEBeginOpcodeMessage 0x3001000AL
#define MSG_RuntimePublisher_GCAllocationTickOpcodeMessage 0x3001000BL
#define MSG_RuntimePublisher_GCCreateConcurrentThreadOpcodeMessage 0x3001000CL
#define MSG_RuntimePublisher_GCTerminateConcurrentThreadOpcodeMessage 0x3001000DL
#define MSG_RuntimePublisher_GCFinalizersEndOpcodeMessage 0x3001000FL
#define MSG_RuntimePublisher_GCFinalizersBeginOpcodeMessage 0x30010013L
#define MSG_RuntimePublisher_GCBulkRootEdgeOpcodeMessage 0x30010014L
#define MSG_RuntimePublisher_GCBulkRootConditionalWeakTableElementEdgeOpcodeMessage 0x30010015L
#define MSG_RuntimePublisher_GCBulkNodeOpcodeMessage 0x30010016L
#define MSG_RuntimePublisher_GCBulkEdgeOpcodeMessage 0x30010017L
#define MSG_RuntimePublisher_GCSampledObjectAllocationOpcodeMessage 0x30010018L
#define MSG_RuntimePublisher_GCBulkSurvivingObjectRangesOpcodeMessage 0x30010019L
#define MSG_RuntimePublisher_GCBulkMovedObjectRangesOpcodeMessage 0x3001001AL
#define MSG_RuntimePublisher_GCGenerationRangeOpcodeMessage 0x3001001BL
#define MSG_RuntimePublisher_GCMarkStackRootsOpcodeMessage 0x3001001CL
#define MSG_RuntimePublisher_GCMarkFinalizeQueueRootsOpcodeMessage 0x3001001DL
#define MSG_RuntimePublisher_GCMarkHandlesOpcodeMessage 0x3001001EL
#define MSG_RuntimePublisher_GCMarkOlderGenerationRootsOpcodeMessage 0x3001001FL
#define MSG_RuntimePublisher_FinalizeObjectOpcodeMessage 0x30010020L
#define MSG_RuntimePublisher_SetGCHandleOpcodeMessage 0x30010021L
#define MSG_RuntimePublisher_DestroyGCHandleOpcodeMessage 0x30010022L
#define MSG_RuntimePublisher_TriggeredOpcodeMessage 0x30010023L
#define MSG_RuntimePublisher_PinObjectAtGCTimeOpcodeMessage 0x30010024L
#define MSG_RuntimePublisher_GCBulkRootCCWOpcodeMessage 0x30010026L
#define MSG_RuntimePublisher_GCBulkRCWOpcodeMessage 0x30010027L
#define MSG_RuntimePublisher_GCBulkRootStaticVarOpcodeMessage 0x30010028L
#define MSG_RuntimePublisher_GCDynamicEventOpcodeMessage 0x30010029L
#define MSG_RuntimePublisher_GCRestartEEEndOpcodeMessage 0x30010084L
#define MSG_RuntimePublisher_GCHeapStatsOpcodeMessage 0x30010085L
#define MSG_RuntimePublisher_GCCreateSegmentOpcodeMessage 0x30010086L
#define MSG_RuntimePublisher_GCFreeSegmentOpcodeMessage 0x30010087L
#define MSG_RuntimePublisher_GCRestartEEBeginOpcodeMessage 0x30010088L
#define MSG_RuntimePublisher_GCSuspendEEEndOpcodeMessage 0x30010089L
#define MSG_RuntimePublisher_IncreaseMemoryPressureOpcodeMessage 0x300100C8L
#define MSG_RuntimePublisher_DecreaseMemoryPressureOpcodeMessage 0x300100C9L
#define MSG_RuntimePublisher_GCMarkOpcodeMessage 0x300100CAL
#define MSG_RuntimePublisher_GCJoinOpcodeMessage 0x300100CBL
#define MSG_RuntimePublisher_GCPerHeapHistoryOpcodeMessage 0x300100CCL
#define MSG_RuntimePublisher_GCGlobalHeapHistoryOpcodeMessage 0x300100CDL
#define MSG_RuntimePublisher_GCLoadedOpcodeMessage 0x300100CEL
#define MSG_RuntimePublisher_DCStartCompleteOpcodeMessage 0x3009000EL
#define MSG_RuntimePublisher_DCEndCompleteOpcodeMessage 0x3009000FL
#define MSG_RuntimePublisher_MethodLoadOpcodeMessage 0x30090021L
#define MSG_RuntimePublisher_MethodUnloadOpcodeMessage 0x30090022L
#define MSG_RuntimePublisher_MethodDCStartOpcodeMessage 0x30090023L
#define MSG_RuntimePublisher_MethodDCEndOpcodeMessage 0x30090024L
#define MSG_RuntimePublisher_MethodLoadVerboseOpcodeMessage 0x30090025L
#define MSG_RuntimePublisher_MethodUnloadVerboseOpcodeMessage 0x30090026L
#define MSG_RuntimePublisher_MethodDCStartVerboseOpcodeMessage 0x30090027L
#define MSG_RuntimePublisher_MethodDCEndVerboseOpcodeMessage 0x30090028L
#define MSG_RuntimePublisher_MethodJittingStartedOpcodeMessage 0x3009002AL
#define MSG_RuntimePublisher_JitInliningSucceededOpcodeMessage 0x30090053L
#define MSG_RuntimePublisher_JitInliningFailedOpcodeMessage 0x30090054L
#define MSG_RuntimePublisher_JitTailCallSucceededOpcodeMessage 0x30090055L
#define MSG_RuntimePublisher_JitTailCallFailedOpcodeMessage 0x30090056L
#define MSG_RuntimePublisher_MethodILToNativeMapOpcodeMessage 0x30090057L
#define MSG_RuntimePublisher_ModuleLoadOpcodeMessage 0x300A0021L
#define MSG_RuntimePublisher_ModuleUnloadOpcodeMessage 0x300A0022L
#define MSG_RuntimePublisher_ModuleDCStartOpcodeMessage 0x300A0023L
#define MSG_RuntimePublisher_ModuleDCEndOpcodeMessage 0x300A0024L
#define MSG_RuntimePublisher_AssemblyLoadOpcodeMessage 0x300A0025L
#define MSG_RuntimePublisher_AssemblyUnloadOpcodeMessage 0x300A0026L
#define MSG_RuntimePublisher_AppDomainLoadOpcodeMessage 0x300A0029L
#define MSG_RuntimePublisher_AppDomainUnloadOpcodeMessage 0x300A002AL
#define MSG_RuntimePublisher_DomainModuleLoadOpcodeMessage 0x300A002DL
#define MSG_RuntimePublisher_CLRStackWalkOpcodeMessage 0x300B0052L
#define MSG_RuntimePublisher_AppDomainMemAllocatedOpcodeMessage 0x300E0030L
#define MSG_RuntimePublisher_AppDomainMemSurvivedOpcodeMessage 0x300E0031L
#define MSG_RuntimePublisher_ThreadCreatedOpcodeMessage 0x300E0032L
#define MSG_RuntimePublisher_ThreadTerminatedOpcodeMessage 0x300E0033L
#define MSG_RuntimePublisher_ThreadDomainEnterOpcodeMessage 0x300E0034L
#define MSG_RuntimePublisher_ILStubGeneratedOpcodeMessage 0x300F0058L
#define MSG_RuntimePublisher_ILStubCacheHitOpcodeMessage 0x300F0059L
#define MSG_RuntimePublisher_WaitOpcodeMessage 0x3010005AL
#define MSG_RuntimePublisher_SampleOpcodeMessage 0x30120064L
#define MSG_RuntimePublisher_AdjustmentOpcodeMessage 0x30120065L
#define MSG_RuntimePublisher_StatsOpcodeMessage 0x30120066L
#define MSG_RuntimePublisher_ModuleRangeLoadOpcodeMessage 0x3014000AL
#define MSG_RuntimePublisher_BulkTypeOpcodeMessage 0x3015000AL
#define MSG_RuntimePublisher_EnqueueOpcodeMessage 0x3017000BL
#define MSG_RuntimePublisher_DequeueOpcodeMessage 0x3017000CL
#define MSG_RuntimePublisher_IOEnqueueOpcodeMessage 0x3017000DL
#define MSG_RuntimePublisher_IODequeueOpcodeMessage 0x3017000EL
#define MSG_RuntimePublisher_IOPackOpcodeMessage 0x3017000FL
#define MSG_RuntimePublisher_ThreadCreatingOpcodeMessage 0x3018000BL
#define MSG_RuntimePublisher_ThreadRunningOpcodeMessage 0x3018000CL
#define MSG_RundownPublisher_DCStartCompleteOpcodeMessage 0x3101000EL
#define MSG_RundownPublisher_DCEndCompleteOpcodeMessage 0x3101000FL
#define MSG_RundownPublisher_DCStartInitOpcodeMessage 0x31010010L
#define MSG_RundownPublisher_DCEndInitOpcodeMessage 0x31010011L
#define MSG_RundownPublisher_MethodDCStartOpcodeMessage 0x31010023L
#define MSG_RundownPublisher_MethodDCEndOpcodeMessage 0x31010024L
#define MSG_RundownPublisher_MethodDCStartVerboseOpcodeMessage 0x31010027L
#define MSG_RundownPublisher_MethodDCEndVerboseOpcodeMessage 0x31010028L
#define MSG_RundownPublisher_MethodDCStartILToNativeMapOpcodeMessage 0x31010029L
#define MSG_RundownPublisher_MethodDCEndILToNativeMapOpcodeMessage 0x3101002AL
#define MSG_RundownPublisher_ModuleDCStartOpcodeMessage 0x31020023L
#define MSG_RundownPublisher_ModuleDCEndOpcodeMessage 0x31020024L
#define MSG_RundownPublisher_AssemblyDCStartOpcodeMessage 0x31020027L
#define MSG_RundownPublisher_AssemblyDCEndOpcodeMessage 0x31020028L
#define MSG_RundownPublisher_AppDomainDCStartOpcodeMessage 0x3102002BL
#define MSG_RundownPublisher_AppDomainDCEndOpcodeMessage 0x3102002CL
#define MSG_RundownPublisher_DomainModuleDCStartOpcodeMessage 0x3102002EL
#define MSG_RundownPublisher_DomainModuleDCEndOpcodeMessage 0x3102002FL
#define MSG_RundownPublisher_ThreadDCOpcodeMessage 0x31020030L
#define MSG_RundownPublisher_CLRStackWalkOpcodeMessage 0x310B0052L
#define MSG_RundownPublisher_ModuleRangeDCStartOpcodeMessage 0x3114000AL
#define MSG_RundownPublisher_ModuleRangeDCEndOpcodeMessage 0x3114000BL
#define MSG_RuntimePublisher_GarbageCollectionTaskMessage 0x70000001L
#define MSG_RuntimePublisher_WorkerThreadCreationTaskMessage 0x70000002L
#define MSG_RuntimePublisher_IOThreadCreationTaskMessage 0x70000003L
#define MSG_RuntimePublisher_WorkerThreadRetirementTaskMessage 0x70000004L
#define MSG_RuntimePublisher_IOThreadRetirementTaskMessage 0x70000005L
#define MSG_RuntimePublisher_ThreadpoolSuspensionTaskMessage 0x70000006L
#define MSG_RuntimePublisher_ExceptionTaskMessage 0x70000007L
#define MSG_RuntimePublisher_ContentionTaskMessage 0x70000008L
#define MSG_RuntimePublisher_MethodTaskMessage 0x70000009L
#define MSG_RuntimePublisher_LoaderTaskMessage 0x7000000AL
#define MSG_RuntimePublisher_StackTaskMessage 0x7000000BL
#define MSG_RuntimePublisher_StrongNameVerificationTaskMessage 0x7000000CL
#define MSG_RuntimePublisher_AuthenticodeVerificationTaskMessage 0x7000000DL
#define MSG_RuntimePublisher_AppDomainResourceManagementTaskMessage 0x7000000EL
#define MSG_RuntimePublisher_ILStubTaskMessage 0x7000000FL
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadTaskMessage 0x70000010L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadRetirementTaskMessage 0x70000011L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentTaskMessage 0x70000012L
#define MSG_RuntimePublisher_EEStartupTaskMessage 0x70000013L
#define MSG_RuntimePublisher_PerfTrackTaskMessage 0x70000014L
#define MSG_RuntimePublisher_TypeTaskMessage 0x70000015L
#define MSG_RuntimePublisher_ThreadPoolWorkingThreadCountTaskMessage 0x70000016L
#define MSG_RuntimePublisher_ThreadPoolTaskMessage 0x70000017L
#define MSG_RuntimePublisher_ThreadTaskMessage 0x70000018L
#define MSG_RuntimePublisher_DebugIPCEventTaskMessage 0x70000019L
#define MSG_RuntimePublisher_DebugExceptionProcessingTaskMessage 0x7000001AL
#define MSG_RuntimePublisher_ExceptionCatchTaskMessage 0x7000001BL
#define MSG_RuntimePublisher_ExceptionFinallyTaskMessage 0x7000001CL
#define MSG_RuntimePublisher_ExceptionFilterTaskMessage 0x7000001DL
#define MSG_RundownPublisher_MethodTaskMessage 0x71000001L
#define MSG_RundownPublisher_LoaderTaskMessage 0x71000002L
#define MSG_RundownPublisher_StackTaskMessage 0x7100000BL
#define MSG_RundownPublisher_EEStartupTaskMessage 0x71000013L
#define MSG_RundownPublisher_PerfTrackTaskMessage 0x71000014L
#define MSG_RuntimePublisher_GCStartEventMessage 0xB0000001L
#define MSG_RuntimePublisher_GCEndEventMessage 0xB0000002L
#define MSG_RuntimePublisher_GCRestartEEEndEventMessage 0xB0000003L
#define MSG_RuntimePublisher_GCHeapStatsEventMessage 0xB0000004L
#define MSG_RuntimePublisher_GCCreateSegmentEventMessage 0xB0000005L
#define MSG_RuntimePublisher_GCFreeSegmentEventMessage 0xB0000006L
#define MSG_RuntimePublisher_GCRestartEEBeginEventMessage 0xB0000007L
#define MSG_RuntimePublisher_GCSuspendEEEndEventMessage 0xB0000008L
#define MSG_RuntimePublisher_GCSuspendEEEventMessage 0xB0000009L
#define MSG_RuntimePublisher_GCAllocationTickEventMessage 0xB000000AL
#define MSG_RuntimePublisher_GCCreateConcurrentThreadEventMessage 0xB000000BL
#define MSG_RuntimePublisher_GCTerminateConcurrentThreadEventMessage 0xB000000CL
#define MSG_RuntimePublisher_GCFinalizersEndEventMessage 0xB000000DL
#define MSG_RuntimePublisher_GCFinalizersBeginEventMessage 0xB000000EL
#define MSG_RuntimePublisher_BulkTypeEventMessage 0xB000000FL
#define MSG_RuntimePublisher_GCBulkRootEdgeEventMessage 0xB0000010L
#define MSG_RuntimePublisher_GCBulkRootConditionalWeakTableElementEdgeEventMessage 0xB0000011L
#define MSG_RuntimePublisher_GCBulkNodeEventMessage 0xB0000012L
#define MSG_RuntimePublisher_GCBulkEdgeEventMessage 0xB0000013L
#define MSG_RuntimePublisher_GCSampledObjectAllocationHighEventMessage 0xB0000014L
#define MSG_RuntimePublisher_GCBulkSurvivingObjectRangesEventMessage 0xB0000015L
#define MSG_RuntimePublisher_GCBulkMovedObjectRangesEventMessage 0xB0000016L
#define MSG_RuntimePublisher_GCGenerationRangeEventMessage 0xB0000017L
#define MSG_RuntimePublisher_GCMarkStackRootsEventMessage 0xB0000019L
#define MSG_RuntimePublisher_GCMarkFinalizeQueueRootsEventMessage 0xB000001AL
#define MSG_RuntimePublisher_GCMarkHandlesEventMessage 0xB000001BL
#define MSG_RuntimePublisher_GCMarkOlderGenerationRootsEventMessage 0xB000001CL
#define MSG_RuntimePublisher_FinalizeObjectEventMessage 0xB000001DL
#define MSG_RuntimePublisher_SetGCHandleEventMessage 0xB000001EL
#define MSG_RuntimePublisher_DestroyGCHandleEventMessage 0xB000001FL
#define MSG_RuntimePublisher_GCSampledObjectAllocationLowEventMessage 0xB0000020L
#define MSG_RuntimePublisher_PinObjectAtGCTimeEventMessage 0xB0000021L
#define MSG_RuntimePublisher_GCTriggeredEventMessage 0xB0000023L
#define MSG_RuntimePublisher_GCBulkRootCCWEventMessage 0xB0000024L
#define MSG_RuntimePublisher_GCBulkRCWEventMessage 0xB0000025L
#define MSG_RuntimePublisher_GCBulkRootStaticVarEventMessage 0xB0000026L
#define MSG_RuntimePublisher_WorkerThreadCreateEventMessage 0xB0000028L
#define MSG_RuntimePublisher_WorkerThreadTerminateEventMessage 0xB0000029L
#define MSG_RuntimePublisher_WorkerThreadRetirementRetireThreadEventMessage 0xB000002AL
#define MSG_RuntimePublisher_WorkerThreadRetirementUnretireThreadEventMessage 0xB000002BL
#define MSG_RuntimePublisher_IOThreadCreateEventMessage 0xB000002CL
#define MSG_RuntimePublisher_IOThreadTerminateEventMessage 0xB000002DL
#define MSG_RuntimePublisher_IOThreadRetirementRetireThreadEventMessage 0xB000002EL
#define MSG_RuntimePublisher_IOThreadRetirementUnretireThreadEventMessage 0xB000002FL
#define MSG_RuntimePublisher_ThreadPoolSuspendSuspendThreadEventMessage 0xB0000030L
#define MSG_RuntimePublisher_ThreadPoolSuspendResumeThreadEventMessage 0xB0000031L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadEventMessage 0xB0000032L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentSampleEventMessage 0xB0000036L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentAdjustmentEventMessage 0xB0000037L
#define MSG_RuntimePublisher_ThreadPoolWorkerThreadAdjustmentStatsEventMessage 0xB0000038L
#define MSG_RuntimePublisher_ThreadPoolWorkingThreadCountEventMessage 0xB000003CL
#define MSG_RuntimePublisher_ThreadPoolEnqueueEventMessage 0xB000003DL
#define MSG_RuntimePublisher_ThreadPoolDequeueEventMessage 0xB000003EL
#define MSG_RuntimePublisher_ThreadPoolIOEnqueueEventMessage 0xB000003FL
#define MSG_RuntimePublisher_ThreadPoolIODequeueEventMessage 0xB0000040L
#define MSG_RuntimePublisher_ThreadPoolIOPackEventMessage 0xB0000041L
#define MSG_RuntimePublisher_ThreadCreatingEventMessage 0xB0000046L
#define MSG_RuntimePublisher_ThreadRunningEventMessage 0xB0000047L
#define MSG_RuntimePublisher_ExceptionExceptionThrownEventMessage 0xB0000050L
#define MSG_RuntimePublisher_ContentionStartEventMessage 0xB0000051L
#define MSG_RuntimePublisher_StackEventMessage 0xB0000052L
#define MSG_RuntimePublisher_AppDomainMemAllocatedEventMessage 0xB0000053L
#define MSG_RuntimePublisher_AppDomainMemSurvivedEventMessage 0xB0000054L
#define MSG_RuntimePublisher_ThreadCreatedEventMessage 0xB0000055L
#define MSG_RuntimePublisher_ThreadTerminatedEventMessage 0xB0000056L
#define MSG_RuntimePublisher_ThreadDomainEnterEventMessage 0xB0000057L
#define MSG_RuntimePublisher_ILStubGeneratedEventMessage 0xB0000058L
#define MSG_RuntimePublisher_ILStubCacheHitEventMessage 0xB0000059L
#define MSG_RuntimePublisher_ContentionStopEventMessage 0xB000005BL
#define MSG_RuntimePublisher_DCStartCompleteEventMessage 0xB0000087L
#define MSG_RuntimePublisher_DCEndCompleteEventMessage 0xB0000088L
#define MSG_RuntimePublisher_MethodDCStartEventMessage 0xB0000089L
#define MSG_RuntimePublisher_MethodDCEndEventMessage 0xB000008AL
#define MSG_RuntimePublisher_MethodDCEndVerboseEventMessage 0xB000008CL
#define MSG_RuntimePublisher_MethodLoadEventMessage 0xB000008DL
#define MSG_RuntimePublisher_MethodUnloadEventMessage 0xB000008EL
#define MSG_RuntimePublisher_MethodLoadVerboseEventMessage 0xB000008FL
#define MSG_RuntimePublisher_MethodUnloadVerboseEventMessage 0xB0000090L
#define MSG_RuntimePublisher_MethodJittingStartedEventMessage 0xB0000091L
#define MSG_RuntimePublisher_ModuleDCStartEventMessage 0xB0000095L
#define MSG_RuntimePublisher_ModuleDCEndEventMessage 0xB0000096L
#define MSG_RuntimePublisher_DomainModuleLoadEventMessage 0xB0000097L
#define MSG_RuntimePublisher_ModuleLoadEventMessage 0xB0000098L
#define MSG_RuntimePublisher_ModuleUnloadEventMessage 0xB0000099L
#define MSG_RuntimePublisher_AssemblyLoadEventMessage 0xB000009AL
#define MSG_RuntimePublisher_AssemblyUnloadEventMessage 0xB000009BL
#define MSG_RuntimePublisher_AppDomainLoadEventMessage 0xB000009CL
#define MSG_RuntimePublisher_AppDomainUnloadEventMessage 0xB000009DL
#define MSG_RuntimePublisher_ModuleRangeLoadEventMessage 0xB000009EL
#define MSG_RuntimePublisher_StrongNameVerificationStartEventMessage 0xB00000B5L
#define MSG_RuntimePublisher_StrongNameVerificationEndEventMessage 0xB00000B6L
#define MSG_RuntimePublisher_AuthenticodeVerificationStartEventMessage 0xB00000B7L
#define MSG_RuntimePublisher_AuthenticodeVerificationEndEventMessage 0xB00000B8L
#define MSG_RuntimePublisher_MethodJitInliningSucceededEventMessage 0xB00000B9L
#define MSG_RuntimePublisher_MethodJitInliningFailedEventMessage 0xB00000BAL
#define MSG_RuntimePublisher_RuntimeInformationEventMessage 0xB00000BBL
#define MSG_RuntimePublisher_MethodJitTailCallSucceededEventMessage 0xB00000BCL
#define MSG_RuntimePublisher_MethodJitTailCallFailedEventMessage 0xB00000BDL
#define MSG_RuntimePublisher_MethodILToNativeMapEventMessage 0xB00000BEL
#define MSG_RuntimePublisher_IncreaseMemoryPressureEventMessage 0xB00000C8L
#define MSG_RuntimePublisher_DecreaseMemoryPressureEventMessage 0xB00000C9L
#define MSG_RuntimePublisher_GCMarkWithTypeEventMessage 0xB00000CAL
#define MSG_RuntimePublisher_GCLoadedEventMessage 0xB00000CEL
#define MSG_RuntimePublisher_ExceptionExceptionHandlingEventMessage 0xB00000FAL
#define MSG_RuntimePublisher_ExceptionExceptionHandlingNoneEventMessage 0xB00000FBL
#define MSG_RuntimePublisher_GCStart_V1EventMessage 0xB0010001L
#define MSG_RuntimePublisher_GCEnd_V1EventMessage 0xB0010002L
#define MSG_RuntimePublisher_GCRestartEEEnd_V1EventMessage 0xB0010003L
#define MSG_RuntimePublisher_GCHeapStats_V1EventMessage 0xB0010004L
#define MSG_RuntimePublisher_GCCreateSegment_V1EventMessage 0xB0010005L
#define MSG_RuntimePublisher_GCFreeSegment_V1EventMessage 0xB0010006L
#define MSG_RuntimePublisher_GCRestartEEBegin_V1EventMessage 0xB0010007L
#define MSG_RuntimePublisher_GCSuspendEEEnd_V1EventMessage 0xB0010008L
#define MSG_RuntimePublisher_GCSuspendEE_V1EventMessage 0xB0010009L
#define MSG_RuntimePublisher_GCAllocationTick_V1EventMessage 0xB001000AL
#define MSG_RuntimePublisher_GCCreateConcurrentThread_V1EventMessage 0xB001000BL
#define MSG_RuntimePublisher_GCTerminateConcurrentThread_V1EventMessage 0xB001000CL
#define MSG_RuntimePublisher_GCFinalizersEnd_V1EventMessage 0xB001000DL
#define MSG_RuntimePublisher_GCFinalizersBegin_V1EventMessage 0xB001000EL
#define MSG_RuntimePublisher_IOThreadCreate_V1EventMessage 0xB001002CL
#define MSG_RuntimePublisher_IOThreadTerminate_V1EventMessage 0xB001002DL
#define MSG_RuntimePublisher_IOThreadRetirementRetireThread_V1EventMessage 0xB001002EL
#define MSG_RuntimePublisher_IOThreadRetirementUnretireThread_V1EventMessage 0xB001002FL
#define MSG_RuntimePublisher_ExceptionExceptionThrown_V1EventMessage 0xB0010050L
#define MSG_RuntimePublisher_ContentionStart_V1EventMessage 0xB0010051L
#define MSG_RuntimePublisher_MethodLoad_V1EventMessage 0xB001008DL
#define MSG_RuntimePublisher_MethodUnload_V1EventMessage 0xB001008EL
#define MSG_RuntimePublisher_MethodLoadVerbose_V1EventMessage 0xB001008FL
#define MSG_RuntimePublisher_MethodUnloadVerbose_V1EventMessage 0xB0010090L
#define MSG_RuntimePublisher_MethodJittingStarted_V1EventMessage 0xB0010091L
#define MSG_RuntimePublisher_DomainModuleLoad_V1EventMessage 0xB0010097L
#define MSG_RuntimePublisher_ModuleLoad_V1EventMessage 0xB0010098L
#define MSG_RuntimePublisher_ModuleUnload_V1EventMessage 0xB0010099L
#define MSG_RuntimePublisher_AssemblyLoad_V1EventMessage 0xB001009AL
#define MSG_RuntimePublisher_AssemblyUnload_V1EventMessage 0xB001009BL
#define MSG_RuntimePublisher_AppDomainLoad_V1EventMessage 0xB001009CL
#define MSG_RuntimePublisher_AppDomainUnload_V1EventMessage 0xB001009DL
#define MSG_RuntimePublisher_StrongNameVerificationStart_V1EventMessage 0xB00100B5L
#define MSG_RuntimePublisher_StrongNameVerificationEnd_V1EventMessage 0xB00100B6L
#define MSG_RuntimePublisher_AuthenticodeVerificationStart_V1EventMessage 0xB00100B7L
#define MSG_RuntimePublisher_AuthenticodeVerificationEnd_V1EventMessage 0xB00100B8L
#define MSG_RuntimePublisher_GCStart_V2EventMessage 0xB0020001L
#define MSG_RuntimePublisher_GCAllocationTick_V2EventMessage 0xB002000AL
#define MSG_RuntimePublisher_MethodLoad_V2EventMessage 0xB002008DL
#define MSG_RuntimePublisher_MethodUnload_V2EventMessage 0xB002008EL
#define MSG_RuntimePublisher_MethodLoadVerbose_V2EventMessage 0xB002008FL
#define MSG_RuntimePublisher_MethodUnloadVerbose_V2EventMessage 0xB0020090L
#define MSG_RuntimePublisher_ModuleLoad_V2EventMessage 0xB0020098L
#define MSG_RuntimePublisher_ModuleUnload_V2EventMessage 0xB0020099L
#define MSG_RuntimePublisher_GCJoin_V2EventMessage 0xB00200CBL
#define MSG_RuntimePublisher_GCGlobalHeap_V2EventMessage 0xB00200CDL
#define MSG_RuntimePublisher_GCAllocationTick_V3EventMessage 0xB003000AL
#define MSG_RuntimePublisher_GCPerHeapHistory_V3EventMessage 0xB00300CCL
#define MSG_RundownPublisher_StackEventMessage 0xB1000000L
#define MSG_RundownPublisher_MethodDCStartEventMessage 0xB100008DL
#define MSG_RundownPublisher_MethodDCEndEventMessage 0xB100008EL
#define MSG_RundownPublisher_MethodDCStartVerboseEventMessage 0xB100008FL
#define MSG_RundownPublisher_MethodDCEndVerboseEventMessage 0xB1000090L
#define MSG_RundownPublisher_MethodDCStartILToNativeMapEventMessage 0xB1000095L
#define MSG_RundownPublisher_MethodDCEndILToNativeMapEventMessage 0xB1000096L
#define MSG_RundownPublisher_DomainModuleDCStartEventMessage 0xB1000097L
#define MSG_RundownPublisher_DomainModuleDCEndEventMessage 0xB1000098L
#define MSG_RundownPublisher_ModuleDCStartEventMessage 0xB1000099L
#define MSG_RundownPublisher_ModuleDCEndEventMessage 0xB100009AL
#define MSG_RundownPublisher_AssemblyDCStartEventMessage 0xB100009BL
#define MSG_RundownPublisher_AssemblyDCEndEventMessage 0xB100009CL
#define MSG_RundownPublisher_AppDomainDCStartEventMessage 0xB100009DL
#define MSG_RundownPublisher_AppDomainDCEndEventMessage 0xB100009EL
#define MSG_RundownPublisher_ThreadCreatedEventMessage 0xB100009FL
#define MSG_RundownPublisher_ModuleRangeDCStartEventMessage 0xB10000A0L
#define MSG_RundownPublisher_ModuleRangeDCEndEventMessage 0xB10000A1L
#define MSG_RundownPublisher_RuntimeInformationEventMessage 0xB10000BBL
#define MSG_RundownPublisher_MethodDCStart_V1EventMessage 0xB101008DL
#define MSG_RundownPublisher_MethodDCEnd_V1EventMessage 0xB101008EL
#define MSG_RundownPublisher_MethodDCStartVerbose_V1EventMessage 0xB101008FL
#define MSG_RundownPublisher_MethodDCEndVerbose_V1EventMessage 0xB1010090L
#define MSG_RundownPublisher_DCStartCompleteEventMessage 0xB1010091L
#define MSG_RundownPublisher_DCEndCompleteEventMessage 0xB1010092L
#define MSG_RundownPublisher_DCStartInitEventMessage 0xB1010093L
#define MSG_RundownPublisher_DCEndInitEventMessage 0xB1010094L
#define MSG_RundownPublisher_DomainModuleDCStart_V1EventMessage 0xB1010097L
#define MSG_RundownPublisher_DomainModuleDCEnd_V1EventMessage 0xB1010098L
#define MSG_RundownPublisher_ModuleDCStart_V1EventMessage 0xB1010099L
#define MSG_RundownPublisher_ModuleDCEnd_V1EventMessage 0xB101009AL
#define MSG_RundownPublisher_AssemblyDCStart_V1EventMessage 0xB101009BL
#define MSG_RundownPublisher_AssemblyDCEnd_V1EventMessage 0xB101009CL
#define MSG_RundownPublisher_AppDomainDCStart_V1EventMessage 0xB101009DL
#define MSG_RundownPublisher_AppDomainDCEnd_V1EventMessage 0xB101009EL
#define MSG_RundownPublisher_MethodDCStart_V2EventMessage 0xB102008DL
#define MSG_RundownPublisher_MethodDCEnd_V2EventMessage 0xB102008EL
#define MSG_RundownPublisher_MethodDCStartVerbose_V2EventMessage 0xB102008FL
#define MSG_RundownPublisher_MethodDCEndVerbose_V2EventMessage 0xB1020090L
#define MSG_RundownPublisher_ModuleDCStart_V2EventMessage 0xB1020099L
#define MSG_RundownPublisher_ModuleDCEnd_V2EventMessage 0xB102009AL
#define MSG_RuntimePublisher_GCSegment_SmallObjectHeapMapMessage 0xD0000001L
#define MSG_RuntimePublisher_GCSegment_LargeObjectHeapMapMessage 0xD0000002L
#define MSG_RuntimePublisher_GCSegment_ReadOnlyHeapMapMessage 0xD0000003L
#define MSG_RuntimePublisher_GCAllocation_SmallMapMessage 0xD0000004L
#define MSG_RuntimePublisher_GCAllocation_LargeMapMessage 0xD0000005L
#define MSG_RuntimePublisher_GCType_NonConcurrentGCMapMessage 0xD0000006L
#define MSG_RuntimePublisher_GCType_BackgroundGCMapMessage 0xD0000007L
#define MSG_RuntimePublisher_GCType_ForegroundGCMapMessage 0xD0000008L
#define MSG_RuntimePublisher_GCReason_AllocSmallMapMessage 0xD0000009L
#define MSG_RuntimePublisher_GCReason_InducedMapMessage 0xD000000AL
#define MSG_RuntimePublisher_GCReason_LowMemoryMapMessage 0xD000000BL
#define MSG_RuntimePublisher_GCReason_EmptyMapMessage 0xD000000CL
#define MSG_RuntimePublisher_GCReason_AllocLargeMapMessage 0xD000000DL
#define MSG_RuntimePublisher_GCReason_OutOfSpaceSmallObjectHeapMapMessage 0xD000000EL
#define MSG_RuntimePublisher_GCReason_OutOfSpaceLargeObjectHeapMapMessage 0xD000000FL
#define MSG_RuntimePublisher_GCReason_InducedNoForceMapMessage 0xD0000010L
#define MSG_RuntimePublisher_GCReason_StressMapMessage 0xD0000011L
#define MSG_RuntimePublisher_GCReason_InducedLowMemoryMapMessage 0xD0000012L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendOtherMapMessage 0xD0000013L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForGCMapMessage 0xD0000014L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForAppDomainShutdownMapMessage 0xD0000015L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForCodePitchingMapMessage 0xD0000016L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForShutdownMapMessage 0xD0000017L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForDebuggerMapMessage 0xD0000018L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForGCPrepMapMessage 0xD0000019L
#define MSG_RuntimePublisher_GCSuspendEEReason_SuspendForDebuggerSweepMapMessage 0xD000001AL
#define MSG_RuntimePublisher_Contention_ManagedMapMessage 0xD000001BL
#define MSG_RuntimePublisher_Contention_NativeMapMessage 0xD000001CL
#define MSG_RuntimePublisher_TailCallType_OptimizedMapMessage 0xD000001DL
#define MSG_RuntimePublisher_TailCallType_RecursiveMapMessage 0xD000001EL
#define MSG_RuntimePublisher_TailCallType_HelperMapMessage 0xD000001FL
#define MSG_RuntimePublisher_ThreadAdjustmentReason_WarmupMapMessage 0xD0000020L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_InitializingMapMessage 0xD0000021L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_RandomMoveMapMessage 0xD0000022L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ClimbingMoveMapMessage 0xD0000023L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ChangePointMapMessage 0xD0000024L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_StabilizingMapMessage 0xD0000025L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_StarvationMapMessage 0xD0000026L
#define MSG_RuntimePublisher_ThreadAdjustmentReason_ThreadTimedOutMapMessage 0xD0000027L
#define MSG_RuntimePublisher_GCRootKind_Stack 0xD0000028L
#define MSG_RuntimePublisher_GCRootKind_Finalizer 0xD0000029L
#define MSG_RuntimePublisher_GCRootKind_Handle 0xD000002AL
#define MSG_RuntimePublisher_GCRootKind_Older 0xD000002BL
#define MSG_RuntimePublisher_GCRootKind_SizedRef 0xD000002CL
#define MSG_RuntimePublisher_GCRootKind_Overflow 0xD000002DL
#define MSG_RuntimePublisher_GCHandleKind_WeakShortMessage 0xD000002EL
#define MSG_RuntimePublisher_GCHandleKind_WeakLongMessage 0xD000002FL
#define MSG_RuntimePublisher_GCHandleKind_StrongMessage 0xD0000030L
#define MSG_RuntimePublisher_GCHandleKind_PinnedMessage 0xD0000031L
#define MSG_RuntimePublisher_GCHandleKind_VariableMessage 0xD0000032L
#define MSG_RuntimePublisher_GCHandleKind_RefCountedMessage 0xD0000033L
#define MSG_RuntimePublisher_GCHandleKind_DependentMessage 0xD0000034L
#define MSG_RuntimePublisher_GCHandleKind_AsyncPinnedMessage 0xD0000035L
#define MSG_RuntimePublisher_GCHandleKind_SizedRefMessage 0xD0000036L
#define MSG_RuntimePublisher_ModuleRangeTypeMap_ColdRangeMessage 0xF0000001L
#define MSG_RuntimePublisher_AppDomain_DefaultMapMessage 0xF0000002L
#define MSG_RuntimePublisher_AppDomain_ExecutableMapMessage 0xF0000003L
#define MSG_RuntimePublisher_AppDomain_SharedMapMessage 0xF0000004L
#define MSG_RuntimePublisher_Assembly_DomainNeutralMapMessage 0xF0000005L
#define MSG_RuntimePublisher_Assembly_DynamicMapMessage 0xF0000006L
#define MSG_RuntimePublisher_Assembly_NativeMapMessage 0xF0000007L
#define MSG_RuntimePublisher_Assembly_CollectibleMapMessage 0xF0000008L
#define MSG_RuntimePublisher_Module_DomainNeutralMapMessage 0xF0000009L
#define MSG_RuntimePublisher_Module_NativeMapMessage 0xF000000AL
#define MSG_RuntimePublisher_Module_DynamicMapMessage 0xF000000BL
#define MSG_RuntimePublisher_Module_ManifestMapMessage 0xF000000CL
#define MSG_RuntimePublisher_Method_DynamicMapMessage 0xF000000DL
#define MSG_RuntimePublisher_Method_GenericMapMessage 0xF000000EL
#define MSG_RuntimePublisher_Method_HasSharedGenericCodeMapMessage 0xF000000FL
#define MSG_RuntimePublisher_Method_JittedMapMessage 0xF0000010L
#define MSG_RuntimePublisher_StartupMode_ManagedExeMapMessage 0xF0000011L
#define MSG_RuntimePublisher_StartupMode_HostedCLRMapMessage 0xF0000012L
#define MSG_RuntimePublisher_StartupMode_IjwDllMapMessage 0xF0000013L
#define MSG_RuntimePublisher_StartupMode_ComActivatedMapMessage 0xF0000014L
#define MSG_RuntimePublisher_StartupMode_OtherMapMessage 0xF0000015L
#define MSG_RuntimePublisher_RuntimeSku_DesktopCLRMapMessage 0xF0000016L
#define MSG_RuntimePublisher_RuntimeSku_CoreCLRMapMessage 0xF0000017L
#define MSG_RuntimePublisher_ExceptionThrown_HasInnerExceptionMapMessage 0xF0000018L
#define MSG_RuntimePublisher_ExceptionThrown_NestedMapMessage 0xF0000019L
#define MSG_RuntimePublisher_ExceptionThrown_ReThrownMapMessage 0xF000001AL
#define MSG_RuntimePublisher_ExceptionThrown_CorruptedStateMapMessage 0xF000001BL
#define MSG_RuntimePublisher_ExceptionThrown_CLSCompliantMapMessage 0xF000001CL
#define MSG_RuntimePublisher_ILStubGenerated_ReverseInteropMapMessage 0xF000001DL
#define MSG_RuntimePublisher_ILStubGenerated_COMInteropMapMessage 0xF000001EL
#define MSG_RuntimePublisher_ILStubGenerated_NGenedStubMapMessage 0xF000001FL
#define MSG_RuntimePublisher_ILStubGenerated_DelegateMapMessage 0xF0000020L
#define MSG_RuntimePublisher_ILStubGenerated_VarArgMapMessage 0xF0000021L
#define MSG_RuntimePublisher_ILStubGenerated_UnmanagedCalleeMapMessage 0xF0000022L
#define MSG_RuntimePublisher_Startup_CONCURRENT_GCMapMessage 0xF0000023L
#define MSG_RuntimePublisher_Startup_LOADER_OPTIMIZATION_SINGLE_DOMAINMapMessage 0xF0000024L
#define MSG_RuntimePublisher_Startup_LOADER_OPTIMIZATION_MULTI_DOMAINMapMessage 0xF0000025L
#define MSG_RuntimePublisher_Startup_LOADER_SAFEMODEMapMessage 0xF0000026L
#define MSG_RuntimePublisher_Startup_LOADER_SETPREFERENCEMapMessage 0xF0000027L
#define MSG_RuntimePublisher_Startup_SERVER_GCMapMessage 0xF0000028L
#define MSG_RuntimePublisher_Startup_HOARD_GC_VMMapMessage 0xF0000029L
#define MSG_RuntimePublisher_Startup_SINGLE_VERSION_HOSTING_INTERFACEMapMessage 0xF000002AL
#define MSG_RuntimePublisher_Startup_LEGACY_IMPERSONATIONMapMessage 0xF000002BL
#define MSG_RuntimePublisher_Startup_DISABLE_COMMITTHREADSTACKMapMessage 0xF000002CL
#define MSG_RuntimePublisher_Startup_ALWAYSFLOW_IMPERSONATIONMapMessage 0xF000002DL
#define MSG_RuntimePublisher_Startup_TRIM_GC_COMMITMapMessage 0xF000002EL
#define MSG_RuntimePublisher_Startup_ETWMapMessage 0xF000002FL
#define MSG_RuntimePublisher_Startup_SERVER_BUILDMapMessage 0xF0000030L
#define MSG_RuntimePublisher_Startup_ARMMapMessage 0xF0000031L
#define MSG_RuntimePublisher_TypeFlags_Delegate 0xF0000032L
#define MSG_RuntimePublisher_TypeFlags_Finalizable 0xF0000033L
#define MSG_RuntimePublisher_TypeFlags_ExternallyImplementedCOMObject 0xF0000034L
#define MSG_RuntimePublisher_TypeFlags_Array 0xF0000035L
#define MSG_RuntimePublisher_GCRootFlags_Pinning 0xF0000036L
#define MSG_RuntimePublisher_GCRootFlags_WeakRef 0xF0000037L
#define MSG_RuntimePublisher_GCRootFlags_Interior 0xF0000038L
#define MSG_RuntimePublisher_GCRootFlags_RefCounted 0xF0000039L
#define MSG_RuntimePublisher_GCRootStaticVarFlags_ThreadLocal 0xF000003AL
#define MSG_RuntimePublisher_GCRootCCWFlags_Strong 0xF000003BL
#define MSG_RuntimePublisher_GCRootCCWFlags_Pegged 0xF000003CL
#define MSG_RuntimePublisher_ThreadFlags_GCSpecial 0xF000003DL
#define MSG_RuntimePublisher_ThreadFlags_Finalizer 0xF000003EL
#define MSG_RuntimePublisher_ThreadFlags_ThreadPoolWorker 0xF000003FL
#define MSG_RundownPublisher_ModuleRangeTypeMap_ColdRangeMessage 0xF1000001L
#define MSG_RundownPublisher_AppDomain_DefaultMapMessage 0xF1000002L
#define MSG_RundownPublisher_AppDomain_ExecutableMapMessage 0xF1000003L
#define MSG_RundownPublisher_AppDomain_SharedMapMessage 0xF1000004L
#define MSG_RundownPublisher_Assembly_DomainNeutralMapMessage 0xF1000005L
#define MSG_RundownPublisher_Assembly_DynamicMapMessage 0xF1000006L
#define MSG_RundownPublisher_Assembly_NativeMapMessage 0xF1000007L
#define MSG_RundownPublisher_Assembly_CollectibleMapMessage 0xF1000008L
#define MSG_RundownPublisher_Module_DomainNeutralMapMessage 0xF1000009L
#define MSG_RundownPublisher_Module_NativeMapMessage 0xF100000AL
#define MSG_RundownPublisher_Module_DynamicMapMessage 0xF100000BL
#define MSG_RundownPublisher_Module_ManifestMapMessage 0xF100000CL
#define MSG_RundownPublisher_Method_DynamicMapMessage 0xF100000DL
#define MSG_RundownPublisher_Method_GenericMapMessage 0xF100000EL
#define MSG_RundownPublisher_Method_HasSharedGenericCodeMapMessage 0xF100000FL
#define MSG_RundownPublisher_Method_JittedMapMessage 0xF1000010L
#define MSG_RundownPublisher_StartupMode_ManagedExeMapMessage 0xF1000011L
#define MSG_RundownPublisher_StartupMode_HostedCLRMapMessage 0xF1000012L
#define MSG_RundownPublisher_StartupMode_IjwDllMapMessage 0xF1000013L
#define MSG_RundownPublisher_StartupMode_ComActivatedMapMessage 0xF1000014L
#define MSG_RundownPublisher_StartupMode_OtherMapMessage 0xF1000015L
#define MSG_RundownPublisher_RuntimeSku_DesktopCLRMapMessage 0xF1000016L
#define MSG_RundownPublisher_RuntimeSku_CoreCLRMapMessage 0xF1000017L
#define MSG_RundownPublisher_Startup_CONCURRENT_GCMapMessage 0xF1000018L
#define MSG_RundownPublisher_Startup_LOADER_OPTIMIZATION_SINGLE_DOMAINMapMessage 0xF1000019L
#define MSG_RundownPublisher_Startup_LOADER_OPTIMIZATION_MULTI_DOMAINMapMessage 0xF100001AL
#define MSG_RundownPublisher_Startup_LOADER_SAFEMODEMapMessage 0xF100001BL
#define MSG_RundownPublisher_Startup_LOADER_SETPREFERENCEMapMessage 0xF100001CL
#define MSG_RundownPublisher_Startup_SERVER_GCMapMessage 0xF100001DL
#define MSG_RundownPublisher_Startup_HOARD_GC_VMMapMessage 0xF100001EL
#define MSG_RundownPublisher_Startup_SINGLE_VERSION_HOSTING_INTERFACEMapMessage 0xF100001FL
#define MSG_RundownPublisher_Startup_LEGACY_IMPERSONATIONMapMessage 0xF1000020L
#define MSG_RundownPublisher_Startup_DISABLE_COMMITTHREADSTACKMapMessage 0xF1000021L
#define MSG_RundownPublisher_Startup_ALWAYSFLOW_IMPERSONATIONMapMessage 0xF1000022L
#define MSG_RundownPublisher_Startup_TRIM_GC_COMMITMapMessage 0xF1000023L
#define MSG_RundownPublisher_Startup_ETWMapMessage 0xF1000024L
#define MSG_RundownPublisher_Startup_SERVER_BUILDMapMessage 0xF1000025L
#define MSG_RundownPublisher_Startup_ARMMapMessage 0xF1000026L
#define MSG_RundownPublisher_ThreadFlags_GCSpecial 0xF1000027L
#define MSG_RundownPublisher_ThreadFlags_Finalizer 0xF1000028L
#define MSG_RundownPublisher_ThreadFlags_ThreadPoolWorker 0xF1000029L
